{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome Turu","text":"<p>Turu is a Simple Database Client for Typed Python.</p> <p> </p> <p> </p>"},{"location":"#why-turu","title":"Why Turu?","text":"<p>SQL is a powerful language, but it has many dialects, and Cloud Native Databases are especially difficult to test automatically in a local environment.</p> <p>Turu was developed as a simple tool to assist local development. It provides a simple interface according to PEP 249 \u2013 Python Database API Specification v2.0 and allows for easy recording of query results and injection mock data.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Simple - Turu is a simple database api wrapper of PEP 249.</li> <li> Type Hint  - Full support for type hints.</li> <li> Async/Await - Async/Await supports.</li> <li> Recoed and Mock - Record and mock database queries for testing.</li> </ul>"},{"location":"#usage","title":"Usage","text":"<pre><code>import pydantic\nimport turu.sqlite3\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.sqlite3.connect(\":memory:\")\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(User, \"SELECT 1, 'taro'\").fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#supprted-database","title":"Supprted Database","text":"Database Sync Support Async Support Installation SQLite3 Yes Yes <code>pip install \"turu[sqlite3]\"</code> MySQL Yes Yes <code>pip install \"turu[mysql]\"</code> PostgreSQL Yes Yes <code>pip install \"turu[postgres]\"</code> Snowflake Yes Yes <code>pip install \"turu[snowflake]\"</code> BigQuery Yes No <code>pip install \"turu[bigquery]\"</code> <p>Warning</p> <p>If you have any dependencies on pyarrow, please install the following stubs in your development environment to avoid errors due to <code>Unknown</code> types.</p> <pre><code># For development\npip install pyarrow-stubs\n</code></pre>"},{"location":"protcol/","title":"PEP 249 Compliant","text":"<p>Turu defines a simple protocol based on PEP 249.</p> <p>All Connection and Cursor class are derived from those protcols.</p> <p>This tool is a simple wrapper for PEP 249 that allows you to specify and inspect the return type with the API you are familiar with.</p> <p>In addition to <code>execute</code>/<code>executemany</code>, we provide <code>execute_map</code>/<code>executemany_map</code> with processing to map query results to a specified type.</p> <pre><code>import pydantic\nimport turu.sqlite3\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.sqlite3.connect(\":memory:\")\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(User, \"SELECT 1, 'taro'\").fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre> <p>Note</p> <p><code>typing.NamedDict</code>/<code>dataclasses.dataclass</code>/<code>pydantic.BaseModel</code> are available as types to map.</p> <p>But, for type validation, we reccomend using pydantic.</p>"},{"location":"protcol/#connection-pool","title":"Connection Pool","text":"<p>Todo</p> <p>Connection Pool may be implemented in the future, but has not yet been started.</p> <p>Reasons:</p> <ul> <li>Turu is developed for use in data analysis workflows and has no incentive to pool connections.</li> <li>Caching strategies exist at different layers, such as RDS Proxy.</li> <li>DbApi3 is not yet in PEP.</li> </ul>"},{"location":"protcol/#connection","title":"Connection","text":"<p>Connection can execute directly, but it is only reading the cursor internally.</p> <pre><code>with connection.execute(\"select 1\") as cursor:\n    ...\n</code></pre> <p>Equivalent to the following.</p> <pre><code>with connection.cursor().execute(\"select 1\") as cursor:\n    ...\n</code></pre> <p>It is recommended that you use this in conjunction with the <code>with</code> syntax and always close the cursor after using it.</p>"},{"location":"protcol/#cursor","title":"Cursor","text":"<p>Always assign a new Cursor as the return value of the <code>execute*</code> method in order to update a type hint that can be retrieved by Cursor.</p> <pre><code>import pydantic\nimport turu.sqlite3\nfrom typing_extensions import Never\n\n\nclass Row(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.sqlite3.connect(\":memory:\")\n\ncursor1: turu.sqlite3.Cursor[Never] = connection.cursor()\ncursor2: turu.sqlite3.Cursor[Row] = cursor1.execute_map(\n    Row, \"SELECT :id, :name\", {\"id\": 1, \"name\": \"taro\"}\n)\n</code></pre>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#response-injection","title":"Response Injection","text":"<p>Turu supports <code>MockConnection</code> for all of the database adapters.</p> <p><code>MockConnection</code> has an <code>inject_response</code> method that allows you to write automated tests by injecting the return value corresponding to the Row type specified in the <code>Cursor.execute_map</code> / <code>Cursor.executemany_map</code>.</p> <pre><code>import turu.sqlite3\nfrom pydantic import BaseModel\n\n\nclass Row(BaseModel):\n    id: int\n    name: str\n\n\nexpected1 = [Row(id=1, name=\"a\"), Row(id=2, name=\"b\")]\nexpected2 = [Row(id=3, name=\"c\"), Row(id=4, name=\"d\")]\nexpected3 = [Row(id=5, name=\"e\"), Row(id=6, name=\"f\")]\n\nconnection = turu.sqlite3.MockConnection()\n\n(\n    connection.chain()\n    .inject_response(Row, expected1)\n    .inject_response(Row, expected2)\n    .inject_response(Row, expected3)\n)\n\nfor expected in [expected1, expected2, expected3]:\n    with connection.cursor() as cursor:\n        assert cursor.execute_map(Row, \"select 1, 'a'\").fetchall() == expected\n</code></pre> <p>Tip</p> <p>The <code>MockConnection.chain</code> method is used to make method chains more readable. It improves code readability when using black formatter.</p> <p>For queries that do not require a return value, such as INSERT, <code>MockConnection.inject_response</code> can be injected as <code>None</code>.</p> <pre><code>import pydantic\nimport turu.snowflake\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\ndef your_logic(connection: turu.snowflake.Connection):\n    with connection.cursor() as cursor:\n        user = cursor.execute_map(\n            User,\n            \"SELECT * FROM users WHERE id = 1\",\n        ).fetchone()\n\n        print(user)\n\n\ndef test_your_logic(connection: turu.snowflake.MockConnection):\n    connection.inject_response(User, [User(id=1, name=\"taro\")])\n\n    your_logic(connection)\n</code></pre>"},{"location":"testing/#operation-injection","title":"Operation Injection","text":"<p>How can I teach <code>MockConnection</code> about operations that do not have a return value, such as <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>?</p> <p>For this purpose, <code>Cursor.execute_with_tag</code> and <code>MockConnection.inject_operation_with_tag</code> are provided.</p> <p>By injecting a tag instead of a return value, MockConnection can determine the type of operation and test whether the calls are made in the intended order.</p> <pre><code>import pydantic\nimport turu.snowflake\nfrom turu.core import tag\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\ndef your_logic(connection: turu.snowflake.Connection):\n    with connection.cursor() as cursor:\n        cursor.execute_with_tag(\n            tag.Update[User],\n            \"UPDATE users SET name = 'jiro' WHERE id = 1\",\n        ).fetchone()\n\n\ndef test_your_logic(connection: turu.snowflake.MockConnection):\n    connection.inject_operation_with_tag(tag.Update[User])\n\n    your_logic(connection)\n</code></pre>"},{"location":"testing/#recording-testing","title":"Recording &amp; Testing","text":"<p>In the production code, the actual rows can be recorded to a csv file using the <code>record_to_csv</code> method.</p> <p>Recording on/off can be controlled with the <code>enable</code> option (default is <code>True</code>).</p> <p>In the test code, the recorded csv is available using the <code>MockConnection.inject_response_from_csv</code> method.</p> <pre><code>import os\n\nimport turu.sqlite3\nfrom pydantic import BaseModel\nfrom turu.core.record import record_to_csv\n\n\nclass Row(BaseModel):\n    id: int\n    name: str\n\n\n# Production code\ndef do_something(connection: turu.sqlite3.Connection):\n    with record_to_csv(\n        \"test.csv\",\n        connection.cursor(),\n        enable=os.environ.get(\"ENABLE_RECORDING\"),\n        limit=100,\n    ) as cursor:\n        cursor.execute_map(Row, \"SELECT 1, 'a'\")\n\n\n# Test code\ndef test_do_something(connection: turu.sqlite3.MockConnection):\n    connection.inject_response_from_csv(Row, \"test.csv\")\n\n    assert do_something(connection) is None\n</code></pre>"},{"location":"adapters/bigquery/","title":"BigQuery Adapter","text":"<p>Tip</p> <p><code>turu-bigquery</code> depends on google-cloud-bigquery.</p> <p>Todo</p> <p><code>turu-bigquery</code> does not support <code>async</code> yet. bigquery does not officially support async.</p>"},{"location":"adapters/bigquery/#installation","title":"Installation","text":"<pre><code>pip install \"turu[bigquery]\"\n</code></pre>"},{"location":"adapters/bigquery/#usage","title":"Usage","text":""},{"location":"adapters/bigquery/#basic-usage","title":"Basic Usage","text":"<pre><code>import pydantic\nimport turu.bigquery\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.bigquery.connect()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT 1, 'taro'\",\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/bigquery/#parameters-usage","title":"Parameters Usage","text":""},{"location":"adapters/bigquery/#format-style","title":"format style","text":"<pre><code>import pydantic\nimport turu.bigquery\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.bigquery.connect()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT %s, %s\",\n        [1, \"taro\"],\n    ).fetchone()\n    assert user == User(id=1, name=\"taro\")\n</code></pre> <p>Warning</p> <p>Official documentation says that \"BigQuery supports qmark parameters\", but it is not.</p>"},{"location":"adapters/bigquery/#keyword-parameters-usage","title":"Keyword Parameters Usage","text":""},{"location":"adapters/bigquery/#named-style","title":"named style","text":"<pre><code>import pydantic\nimport turu.bigquery\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.bigquery.connect()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT %(id)s, %(name)s\",\n        {\"id\": 1, \"name\": \"taro\"},\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre> <p>Info</p> <p>bigquery supports \"Providing explicit type information\". Please see more information in official documentation.</p>"},{"location":"adapters/mysql/","title":"MySQL Adapter","text":"<p>Tip</p> <p><code>turu-mysql</code> depends on aiomysql.</p>"},{"location":"adapters/mysql/#installation","title":"Installation","text":"<pre><code>pip install \"turu[mysql]\"\n</code></pre>"},{"location":"adapters/mysql/#usage","title":"Usage","text":""},{"location":"adapters/mysql/#basic-usage","title":"Basic Usage","text":"<pre><code>import pydantic\nimport turu.mysql\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.mysql.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT 1, 'taro'\",\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/mysql/#parameters-usage","title":"Parameters Usage","text":""},{"location":"adapters/mysql/#format-style","title":"format style","text":"<pre><code>import pydantic\nimport turu.mysql\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.mysql.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT %s, %s\",\n        (1, \"taro\"),\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/mysql/#keyword-parameters-usage","title":"Keyword Parameters Usage","text":""},{"location":"adapters/mysql/#pyformat-style","title":"pyformat style","text":"<pre><code>import pydantic\nimport turu.mysql\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.mysql.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT %(id)s, %(name)s\",\n        {\"id\": 1, \"name\": \"taro\"},\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/postgres/","title":"PostgreSQL Adapter","text":"<p>Tip</p> <p><code>turu-postgres</code> depends on psycopg.</p>"},{"location":"adapters/postgres/#installation","title":"Installation","text":"<pre><code>pip install \"turu[postgres]\"\n</code></pre>"},{"location":"adapters/postgres/#usage","title":"Usage","text":""},{"location":"adapters/postgres/#basic-usage","title":"Basic Usage","text":"<pre><code>import pydantic\nimport turu.postgres\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.postgres.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(User, \"SELECT 1, 'taro'\").fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/postgres/#parameters-usage","title":"Parameters Usage","text":""},{"location":"adapters/postgres/#format-style","title":"format style","text":"<pre><code>import pydantic\nimport turu.postgres\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.postgres.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT %s, %s\",\n        [1, \"taro\"],\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre> <p>Warning</p> <p>The variables placeholder must always be a <code>%s</code>, even if a different placeholder (such as a <code>%d</code> for integers or <code>%f</code> for floats) may look more appropriate for the type.</p>"},{"location":"adapters/postgres/#keyword-parameters-usage","title":"Keyword Parameters Usage","text":""},{"location":"adapters/postgres/#pyformat-style","title":"pyformat style","text":"<pre><code>import pydantic\nimport turu.postgres\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.postgres.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT %(id)s, %(name)s\",\n        {\"id\": 1, \"name\": \"taro\"},\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/snowflake/","title":"Snowflake Adapter","text":"<p>Tip</p> <p><code>turu-snowflake</code> depends on snowflake-connector-python.</p>"},{"location":"adapters/snowflake/#installation","title":"Installation","text":"<pre><code>pip install \"turu[snowflake]\"\n</code></pre> <p>Warning</p> <p>If you have any dependencies on pyarrow, please install the following stubs in your development environment to avoid errors due to <code>Unknown</code> types.</p> <pre><code># For development\npip install pyarrow-stubs\n</code></pre>"},{"location":"adapters/snowflake/#usage","title":"Usage","text":""},{"location":"adapters/snowflake/#basic-usage","title":"Basic Usage","text":"<pre><code>import pydantic\nimport turu.snowflake\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.snowflake.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT 1, 'taro'\",\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/snowflake/#parameters-usage","title":"Parameters Usage","text":""},{"location":"adapters/snowflake/#format-style","title":"format style","text":"<pre><code>import pydantic\nimport turu.snowflake\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.snowflake.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT %s, %s\",\n        [1, \"taro\"],\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre> <p>Warning</p> <p>The variables placeholder must always be a <code>%s</code>, even if a different placeholder (such as a <code>%d</code> for integers or <code>%f</code> for floats) may look more appropriate for the type.</p>"},{"location":"adapters/snowflake/#keyword-parameters-usage","title":"Keyword Parameters Usage","text":""},{"location":"adapters/snowflake/#pyformat-style","title":"pyformat style","text":"<pre><code>import pydantic\nimport turu.snowflake\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.snowflake.connect_from_env()\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT %(id)s, %(name)s\",\n        {\"id\": 1, \"name\": \"taro\"},\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/snowflake/#use-methods","title":"Use methods","text":"<p><code>turu.snowflake.Cursor</code> supports <code>use_*</code> methods to set options.</p> <ul> <li>use_warehouse</li> <li>use_database</li> <li>use_schema</li> <li>use_role</li> </ul> <pre><code>import os\n\nimport pydantic\nimport turu.snowflake\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.snowflake.connect_from_env()\n\nwith (\n    connection.cursor()\n    .use_warehouse(os.environ[\"SNOWFLAKE_WAREHOUSE\"])\n    .use_database(os.environ[\"SNOWFLAKE_DATABASE\"])\n) as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT 1, 'taro'\",\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre> <p>Tip</p> <p><code>use_*</code> methods are not supported in <code>turu.snowflake.Connection</code>. Settings for connection creation should be specified in the constructor.</p> <p>Tip</p> <p><code>AsyncCursor.use_*</code> methods are not async. This is intentionally done in sync because of the short processing time of those methods and the deteriorating readability caused by method chaining.</p>"},{"location":"adapters/snowflake/#pandas-dataframe-validation-using-pandera","title":"Pandas DataFrame Validation using Pandera","text":"<p>You can use Pandera to validate the <code>pandas.DataFrame</code>.</p> <p>Note</p> <p>Pandera is optional feature. If you want to use Pandera, you need to install pandera like this:</p> <pre><code>pip install pandera\n</code></pre> <pre><code>import pandera as pa\nimport pytest\nimport turu.snowflake\nfrom pandera.errors import SchemaError\nfrom pandera.typing import DataFrame, Series\n\n\nclass User(pa.DataFrameModel):\n    id: Series[pa.Int8] = pa.Field(ge=2, alias=\"ID\")\n\n\nconnection = turu.snowflake.connect_from_env()\n\nwith pytest.raises(SchemaError):\n    with connection.cursor() as cursor:\n        df: DataFrame[User] = cursor.execute_map(\n            User,\n            \"\"\"\n            SELECT 1 AS id\n            UNION ALL\n            SELECT 2 AS id\n            \"\"\",\n        ).fetch_pandas_all()\n</code></pre>"},{"location":"adapters/sqlite3/","title":"SQLite3 Adapter","text":"<p>Tip</p> <p><code>turu-sqlite3</code> depends on aiosqlite.</p>"},{"location":"adapters/sqlite3/#installation","title":"Installation","text":"<pre><code>pip install \"turu[sqlite3]\"\n</code></pre>"},{"location":"adapters/sqlite3/#usage","title":"Usage","text":""},{"location":"adapters/sqlite3/#basic-usage","title":"Basic Usage","text":"<pre><code>import pydantic\nimport turu.sqlite3\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.sqlite3.connect(\":memory:\")\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(User, \"SELECT 1, 'taro'\").fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/sqlite3/#parameters-usage","title":"Parameters Usage","text":""},{"location":"adapters/sqlite3/#qmark-style","title":"qmark style","text":"<pre><code>import pydantic\nimport turu.sqlite3\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.sqlite3.connect(\":memory:\")\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT ?, ?\",\n        [1, \"taro\"],\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"adapters/sqlite3/#keyword-parameters-usage","title":"Keyword Parameters Usage","text":""},{"location":"adapters/sqlite3/#named-style","title":"named style","text":"<pre><code>import pydantic\nimport turu.sqlite3\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n\n\nconnection = turu.sqlite3.connect(\":memory:\")\n\nwith connection.cursor() as cursor:\n    user = cursor.execute_map(\n        User,\n        \"SELECT :id, :name\",\n        {\"id\": 1, \"name\": \"taro\"},\n    ).fetchone()\n\n    assert user == User(id=1, name=\"taro\")\n</code></pre>"},{"location":"api/turu-bigquery/","title":"turu.bigquery","text":""},{"location":"api/turu-bigquery/#turu.bigquery.Connection","title":"<code>turu.bigquery.Connection</code>","text":"Source code in <code>turu-bigquery/src/turu/bigquery/connection.py</code> <pre><code>class Connection(turu.core.connection.Connection):\n    def __init__(self, connection: google.cloud.bigquery.dbapi.Connection):\n        self._raw_connection = connection\n\n    @override\n    @classmethod\n    def connect(  # type: ignore[override]\n        cls,\n        client: Optional[google.cloud.bigquery.Client] = None,\n        bqstorage_client: Optional[BigQueryReadClient] = None,\n    ) -&gt; Self:\n        import google.cloud.bigquery\n        import google.cloud.bigquery.dbapi\n\n        return cls(\n            google.cloud.bigquery.dbapi.connect(\n                client=client,\n                bqstorage_client=bqstorage_client,\n            ),\n        )\n\n    @classmethod\n    @override\n    def connect_from_env(cls, *args: Any, **kwargs: Any) -&gt; Self:\n        return cls.connect(*args, **kwargs)\n\n    @override\n    def close(self) -&gt; None:\n        \"\"\"Close the connection and any cursors created from it.\"\"\"\n\n        self._raw_connection.close()\n\n    @override\n    def commit(self) -&gt; None:\n        \"\"\"No-op, but for consistency raise an error if connection is closed.\"\"\"\n\n        self._raw_connection.commit()\n\n    @deprecated(\"rollback is not supported in BigQuery\")\n    def rollback(self) -&gt; None:\n        raise NotImplementedError()\n\n    @override\n    def cursor(self) -&gt; Cursor[Never]:\n        \"\"\"Return a new cursor object.\"\"\"\n\n        return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Connection.close","title":"<code>close()</code>","text":"<p>Close the connection and any cursors created from it.</p> Source code in <code>turu-bigquery/src/turu/bigquery/connection.py</code> <pre><code>@override\ndef close(self) -&gt; None:\n    \"\"\"Close the connection and any cursors created from it.\"\"\"\n\n    self._raw_connection.close()\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Connection.commit","title":"<code>commit()</code>","text":"<p>No-op, but for consistency raise an error if connection is closed.</p> Source code in <code>turu-bigquery/src/turu/bigquery/connection.py</code> <pre><code>@override\ndef commit(self) -&gt; None:\n    \"\"\"No-op, but for consistency raise an error if connection is closed.\"\"\"\n\n    self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Connection.connect","title":"<code>connect(client=None, bqstorage_client=None)</code>  <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-bigquery/src/turu/bigquery/connection.py</code> <pre><code>@override\n@classmethod\ndef connect(  # type: ignore[override]\n    cls,\n    client: Optional[google.cloud.bigquery.Client] = None,\n    bqstorage_client: Optional[BigQueryReadClient] = None,\n) -&gt; Self:\n    import google.cloud.bigquery\n    import google.cloud.bigquery.dbapi\n\n    return cls(\n        google.cloud.bigquery.dbapi.connect(\n            client=client,\n            bqstorage_client=bqstorage_client,\n        ),\n    )\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Connection.connect_from_env","title":"<code>connect_from_env(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-bigquery/src/turu/bigquery/connection.py</code> <pre><code>@classmethod\n@override\ndef connect_from_env(cls, *args: Any, **kwargs: Any) -&gt; Self:\n    return cls.connect(*args, **kwargs)\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Connection.cursor","title":"<code>cursor()</code>","text":"<p>Return a new cursor object.</p> Source code in <code>turu-bigquery/src/turu/bigquery/connection.py</code> <pre><code>@override\ndef cursor(self) -&gt; Cursor[Never]:\n    \"\"\"Return a new cursor object.\"\"\"\n\n    return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Connection.rollback","title":"<code>rollback()</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-bigquery/src/turu/bigquery/connection.py</code> <pre><code>@deprecated(\"rollback is not supported in BigQuery\")\ndef rollback(self) -&gt; None:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor","title":"<code>turu.bigquery.Cursor</code>","text":"Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>class Cursor(turu.core.cursor.Cursor[turu.core.cursor.GenericRowType, Parameter]):\n    def __init__(\n        self,\n        cursor: google.cloud.bigquery.dbapi.Cursor,\n        *,\n        row_type: Optional[Type[turu.core.cursor.GenericRowType]] = None,\n    ):\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[turu.core.cursor.GenericRowType]] = row_type\n\n    @property\n    def rowcount(self) -&gt; int:\n        \"\"\"\n        The rowcount for the last .execute*() operation.\n\n        Per PEP 249: The attribute is -1 in case no .execute*() has been\n        performed on the cursor or the rowcount of the last operation\n        cannot be determined by the interface.\n        \"\"\"\n        return self._raw_cursor.rowcount\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize or -1\n\n    @arraysize.setter\n    @deprecated(\"arraysize is not supported in BigQuery\")\n    def arraysize(self, size: int) -&gt; None:\n        \"\"\"\n        The arraysize for fetchmany and fetchall.\n\n        Per PEP 249: The arraysize attribute defaults to 1, meaning to fetch\n        a single row at a time. However, we deviate from that, and set the\n        default to None, allowing the backend to automatically determine the\n        most appropriate size.\n        \"\"\"\n        self._raw_cursor.arraysize\n        raise NotImplementedError()\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_cursor.close()\n\n    @override\n    def execute(\n        self,\n        operation: str,\n        parameters: Optional[Parameter] = None,\n        /,\n    ) -&gt; \"Cursor[Tuple[Any]]\":\n        self._raw_cursor.execute(operation, parameters)\n        self._row_type = None\n\n        return cast(Cursor, self)\n\n    @override\n    def executemany(\n        self,\n        operation: str,\n        seq_of_parameters: Union[Sequence[Mapping[str, Any]], Sequence[Any]],\n        /,\n    ) -&gt; \"Cursor[Tuple[Any]]\":\n        self._raw_cursor.executemany(operation, seq_of_parameters)\n        self._row_type = None\n\n        return cast(Cursor, self)\n\n    @override\n    def execute_map(\n        self,\n        row_type: Type[turu.core.cursor.GenericNewRowType],\n        operation: str,\n        parameters: \"Optional[Parameter]\" = None,\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n        self._raw_cursor.execute(operation, parameters)\n        self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @override\n    def executemany_map(\n        self,\n        row_type: Type[turu.core.cursor.GenericNewRowType],\n        operation: str,\n        seq_of_parameters: Union[Sequence[Mapping[str, Any]], Sequence[Any]],\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n        self._raw_cursor.executemany(operation, seq_of_parameters)\n        self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @override\n    def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: \"Optional[Parameter]\" = None,\n    ) -&gt; \"Cursor[Never]\":\n        return cast(Cursor, self.execute(operation, parameters))\n\n    @override\n    def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: \"Sequence[Parameter]\",\n    ) -&gt; \"Cursor[Never]\":\n        return cast(Cursor, self.executemany(operation, seq_of_parameters))\n\n    @override\n    def fetchone(self) -&gt; Optional[turu.core.cursor.GenericRowType]:\n        row = self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        elif self._row_type is not None:\n            return _map_row(self._row_type, row)\n\n        else:\n            return tuple(row)  # type: ignore[return-value]\n\n    @override\n    def fetchmany(\n        self, size: Optional[int] = None\n    ) -&gt; List[turu.core.cursor.GenericRowType]:\n        return [\n            _map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchmany(\n                size if size is not None else self.arraysize\n            )\n        ]\n\n    @override\n    def fetchall(self) -&gt; List[turu.core.cursor.GenericRowType]:\n        return [_map_row(self._row_type, row) for row in self._raw_cursor.fetchall()]\n\n    @override\n    def __next__(self) -&gt; turu.core.cursor.GenericRowType:\n        next_row = self._raw_cursor.fetchone()\n\n        if next_row is None:\n            raise StopIteration()\n\n        if self._row_type is not None:\n            return _map_row(self._row_type, next_row)\n\n        else:\n            return tuple(next_row)  # type: ignore[return-value]\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>The number of rows to fetch at a time with <code>.fetchmany()</code>.</p> <p>It defaults to 1 meaning to fetch a single row at a time.</p>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>The rowcount for the last .execute*() operation.</p> <p>Per PEP 249: The attribute is -1 in case no .execute*() has been performed on the cursor or the rowcount of the last operation cannot be determined by the interface.</p>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.execute","title":"<code>execute(operation, parameters=None)</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef execute(\n    self,\n    operation: str,\n    parameters: Optional[Parameter] = None,\n    /,\n) -&gt; \"Cursor[Tuple[Any]]\":\n    self._raw_cursor.execute(operation, parameters)\n    self._row_type = None\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None)</code>","text":"<p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Cursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef execute_map(\n    self,\n    row_type: Type[turu.core.cursor.GenericNewRowType],\n    operation: str,\n    parameters: \"Optional[Parameter]\" = None,\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n    self._raw_cursor.execute(operation, parameters)\n    self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: \"Optional[Parameter]\" = None,\n) -&gt; \"Cursor[Never]\":\n    return cast(Cursor, self.execute(operation, parameters))\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.executemany","title":"<code>executemany(operation, seq_of_parameters)</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef executemany(\n    self,\n    operation: str,\n    seq_of_parameters: Union[Sequence[Mapping[str, Any]], Sequence[Any]],\n    /,\n) -&gt; \"Cursor[Tuple[Any]]\":\n    self._raw_cursor.executemany(operation, seq_of_parameters)\n    self._row_type = None\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Cursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef executemany_map(\n    self,\n    row_type: Type[turu.core.cursor.GenericNewRowType],\n    operation: str,\n    seq_of_parameters: Union[Sequence[Mapping[str, Any]], Sequence[Any]],\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n    self._raw_cursor.executemany(operation, seq_of_parameters)\n    self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: \"Sequence[Parameter]\",\n) -&gt; \"Cursor[Never]\":\n    return cast(Cursor, self.executemany(operation, seq_of_parameters))\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.fetchall","title":"<code>fetchall()</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef fetchall(self) -&gt; List[turu.core.cursor.GenericRowType]:\n    return [_map_row(self._row_type, row) for row in self._raw_cursor.fetchall()]\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.fetchmany","title":"<code>fetchmany(size=None)</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef fetchmany(\n    self, size: Optional[int] = None\n) -&gt; List[turu.core.cursor.GenericRowType]:\n    return [\n        _map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchmany(\n            size if size is not None else self.arraysize\n        )\n    ]\n</code></pre>"},{"location":"api/turu-bigquery/#turu.bigquery.Cursor.fetchone","title":"<code>fetchone()</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-bigquery/src/turu/bigquery/cursor.py</code> <pre><code>@override\ndef fetchone(self) -&gt; Optional[turu.core.cursor.GenericRowType]:\n    row = self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    elif self._row_type is not None:\n        return _map_row(self._row_type, row)\n\n    else:\n        return tuple(row)  # type: ignore[return-value]\n</code></pre>"},{"location":"api/turu-core/","title":"turu.core","text":""},{"location":"api/turu-core/#turu.core.record.record_to_csv","title":"<code>turu.core.record.record_to_csv(record_filepath, cursor, *, enable=True, **options)</code>","text":"<pre><code>record_to_csv(record_filepath: Union[str, Path], cursor: turu.core.cursor.GenericCursor, *, enable: Union[str, bool, None] = True, **options: Unpack[CsvRecorderOptions]) -&gt; _GeneratorContextManager[turu.core.cursor.GenericCursor]\n</code></pre><pre><code>record_to_csv(record_filepath: Union[str, Path], cursor: turu.core.async_cursor.GenericAsyncCursor, *, enable: Union[str, bool, None] = True, **options: Unpack[CsvRecorderOptions]) -&gt; _AsyncGeneratorContextManager[turu.core.async_cursor.GenericAsyncCursor]\n</code></pre> <p>Records cursor's fetched data to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>record_filepath</code> <code>Union[str, Path]</code> <p>Path to record file.</p> required <code>cursor</code> <code>Union[GenericCursor, GenericAsyncCursor]</code> <p>Cursor to record.</p> required <code>enable</code> <code>Union[str, bool, None]</code> <p>Enable recording.</p> <code>True</code> <code>options</code> <code>Unpack[CsvRecorderOptions]</code> <p>Options for CSV recorder.</p> <code>{}</code> Source code in <code>turu-core/src/turu/core/record/__init__.py</code> <pre><code>def record_to_csv(  # type: ignore\n    record_filepath: Union[str, Path],\n    cursor: Union[\n        turu.core.cursor.GenericCursor, turu.core.async_cursor.GenericAsyncCursor\n    ],\n    *,\n    enable: Union[str, bool, None] = True,\n    **options: Unpack[CsvRecorderOptions],\n):\n    \"\"\"Records cursor's fetched data to CSV.\n\n    Parameters:\n        record_filepath: Path to record file.\n        cursor: Cursor to record.\n        enable: Enable recording.\n        options: Options for CSV recorder.\n    \"\"\"\n    if isinstance(cursor, turu.core.cursor.Cursor):\n        return _GeneratorContextManager(\n            _record_to_csv, (record_filepath, cursor), dict(enable=enable, **options)\n        )\n\n    elif isinstance(cursor, turu.core.async_cursor.AsyncCursor):\n        return _AsyncGeneratorContextManager(\n            _record_to_csv_async,\n            (record_filepath, cursor),\n            dict(enable=enable, **options),\n        )\n\n    raise NotImplementedError(f\"cursor type {type(cursor)} is not supported\")\n</code></pre>"},{"location":"api/turu-core/#turu.core.record.CsvRecorderOptions","title":"<code>turu.core.record.CsvRecorderOptions</code>","text":"<p>Options for CSV recorder.</p> Source code in <code>turu-core/src/turu/core/record/csv_recorder.py</code> <pre><code>class CsvRecorderOptions(TypedDict):\n    \"\"\"Options for CSV recorder.\"\"\"\n\n    header: NotRequired[bool]\n    \"\"\"Whether to write header or not.\"\"\"\n\n    limit: NotRequired[int]\n    \"\"\"Limit of rows to write.\"\"\"\n</code></pre>"},{"location":"api/turu-core/#turu.core.record.CsvRecorderOptions.header","title":"<code>header: NotRequired[bool]</code>  <code>instance-attribute</code>","text":"<p>Whether to write header or not.</p>"},{"location":"api/turu-core/#turu.core.record.CsvRecorderOptions.limit","title":"<code>limit: NotRequired[int]</code>  <code>instance-attribute</code>","text":"<p>Limit of rows to write.</p>"},{"location":"api/turu-mysql/","title":"turu.mysql","text":""},{"location":"api/turu-mysql/#turu.mysql.Connection","title":"<code>turu.mysql.Connection</code>","text":"Source code in <code>turu-mysql/src/turu/mysql/connection.py</code> <pre><code>class Connection(turu.core.connection.Connection):\n    def __init__(self, connection: pymysql.Connection) -&gt; None:\n        self._raw_connection = connection\n\n    @override\n    @classmethod\n    def connect(  # type: ignore[override]\n        cls,\n        user: Optional[str] = None,\n        password: str = \"\",\n        host: Optional[str] = None,\n        database: Optional[str] = None,\n        port: int = 0,\n        **kwargs: Unpack[\"_ConnectParams\"],\n    ) -&gt; Self:\n        return cls(\n            pymysql.connect(\n                user=user,\n                password=password,\n                host=host,\n                database=database,\n                port=port,\n                **kwargs,\n            )\n        )\n\n    @override\n    @classmethod\n    def connect_from_env(  # type: ignore[override]\n        cls,\n        user_envname: str = \"MYSQL_USER\",\n        password_envname: str = \"MYSQL_PASSWORD\",\n        host_envname: str = \"MYSQL_HOST\",\n        database_envname: str = \"MYSQL_DATABASE\",\n        port_envname: str = \"MYSQL_PORT\",\n        **kwargs: Unpack[\"_ConnectParams\"],\n    ) -&gt; Self:\n        return cls.connect(\n            user=os.environ.get(user_envname),\n            password=os.environ.get(password_envname, \"\"),\n            host=os.environ.get(host_envname),\n            database=os.environ.get(database_envname),\n            port=int(os.environ.get(port_envname, 0)),\n            **kwargs,\n        )\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_connection.close()\n\n    @override\n    def commit(self) -&gt; None:\n        self._raw_connection.commit()\n\n    @override\n    def rollback(self) -&gt; None:\n        self._raw_connection.rollback()\n\n    @override\n    def cursor(self) -&gt; \"Cursor[Never]\":\n        return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Connection.close","title":"<code>close()</code>","text":"<p>Close the connection now.</p> Source code in <code>turu-mysql/src/turu/mysql/connection.py</code> <pre><code>@override\ndef close(self) -&gt; None:\n    self._raw_connection.close()\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Connection.commit","title":"<code>commit()</code>","text":"<p>Commit any pending transaction to the database.</p> Source code in <code>turu-mysql/src/turu/mysql/connection.py</code> <pre><code>@override\ndef commit(self) -&gt; None:\n    self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Connection.connect","title":"<code>connect(user=None, password='', host=None, database=None, port=0, **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-mysql/src/turu/mysql/connection.py</code> <pre><code>@override\n@classmethod\ndef connect(  # type: ignore[override]\n    cls,\n    user: Optional[str] = None,\n    password: str = \"\",\n    host: Optional[str] = None,\n    database: Optional[str] = None,\n    port: int = 0,\n    **kwargs: Unpack[\"_ConnectParams\"],\n) -&gt; Self:\n    return cls(\n        pymysql.connect(\n            user=user,\n            password=password,\n            host=host,\n            database=database,\n            port=port,\n            **kwargs,\n        )\n    )\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Connection.connect_from_env","title":"<code>connect_from_env(user_envname='MYSQL_USER', password_envname='MYSQL_PASSWORD', host_envname='MYSQL_HOST', database_envname='MYSQL_DATABASE', port_envname='MYSQL_PORT', **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-mysql/src/turu/mysql/connection.py</code> <pre><code>@override\n@classmethod\ndef connect_from_env(  # type: ignore[override]\n    cls,\n    user_envname: str = \"MYSQL_USER\",\n    password_envname: str = \"MYSQL_PASSWORD\",\n    host_envname: str = \"MYSQL_HOST\",\n    database_envname: str = \"MYSQL_DATABASE\",\n    port_envname: str = \"MYSQL_PORT\",\n    **kwargs: Unpack[\"_ConnectParams\"],\n) -&gt; Self:\n    return cls.connect(\n        user=os.environ.get(user_envname),\n        password=os.environ.get(password_envname, \"\"),\n        host=os.environ.get(host_envname),\n        database=os.environ.get(database_envname),\n        port=int(os.environ.get(port_envname, 0)),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Connection.cursor","title":"<code>cursor()</code>","text":"<p>Return a new Cursor Object using the connection.</p> Source code in <code>turu-mysql/src/turu/mysql/connection.py</code> <pre><code>@override\ndef cursor(self) -&gt; \"Cursor[Never]\":\n    return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Connection.rollback","title":"<code>rollback()</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-mysql/src/turu/mysql/connection.py</code> <pre><code>@override\ndef rollback(self) -&gt; None:\n    self._raw_connection.rollback()\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor","title":"<code>turu.mysql.Cursor</code>","text":"Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>class Cursor(\n    turu.core.cursor.Cursor[turu.core.cursor.GenericRowType, Parameters],\n):\n    def __init__(\n        self,\n        cursor: pymysql.cursors.Cursor,\n        *,\n        row_type: Optional[Type[turu.core.cursor.GenericRowType]] = None,\n    ):\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[turu.core.cursor.GenericRowType]] = row_type\n        self._iter = None\n\n    @property\n    def rowcount(self) -&gt; int:\n        return self._raw_cursor.rowcount\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize\n\n    @arraysize.setter\n    def arraysize(self, size: int) -&gt; None:\n        self._raw_cursor.arraysize = size\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_cursor.close()\n\n    @override\n    def execute(\n        self,\n        operation: str,\n        parameters: Optional[Parameters] = None,\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n        self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n        self._row_type = None\n\n        return self\n\n    @override\n    def executemany(\n        self,\n        operation: str,\n        seq_of_parameters: Sequence[Parameters],\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n        self._raw_cursor.executemany(cast(LiteralString, operation), seq_of_parameters)\n        self._row_type = None\n\n        return self\n\n    @override\n    def execute_map(\n        self,\n        row_type: Type[turu.core.cursor.GenericNewRowType],\n        operation: str,\n        parameters: Optional[Parameters] = None,\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n        self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n        self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n        return self  # type: ignore\n\n    @override\n    def executemany_map(\n        self,\n        row_type: Type[turu.core.cursor.GenericNewRowType],\n        operation: str,\n        seq_of_parameters: Sequence[Parameters],\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n        self._raw_cursor.executemany(cast(LiteralString, operation), seq_of_parameters)\n        self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @override\n    def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: \"Optional[Parameters]\" = None,\n    ) -&gt; \"Cursor[Never]\":\n        return cast(Cursor, self.execute(operation, parameters))\n\n    @override\n    def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: \"Sequence[Parameters]\",\n    ) -&gt; \"Cursor[Never]\":\n        return cast(Cursor, self.executemany(operation, seq_of_parameters))\n\n    @override\n    def fetchone(self) -&gt; Optional[turu.core.cursor.GenericRowType]:\n        row = self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        elif self._row_type is not None:\n            return turu.core.cursor.map_row(self._row_type, row)\n\n        else:\n            return row  # type: ignore\n\n    @override\n    def fetchmany(\n        self, size: Optional[int] = None\n    ) -&gt; List[turu.core.cursor.GenericRowType]:\n        return [\n            turu.core.cursor.map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchmany(\n                size if size is not None else self.arraysize\n            )\n        ]\n\n    @override\n    def fetchall(self) -&gt; List[turu.core.cursor.GenericRowType]:\n        return [\n            turu.core.cursor.map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchall()\n        ]\n\n    @override\n    def __iter__(self) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n        self._iter = self._raw_cursor.__iter__()\n        return self\n\n    @override\n    def __next__(self) -&gt; turu.core.cursor.GenericRowType:\n        if self._iter is None:\n            self._iter = self._raw_cursor.__iter__()\n\n        next_row = next(self._iter)\n        if self._row_type is not None and next_row is not None:\n            return turu.core.cursor.map_row(self._row_type, next_row)\n\n        else:\n            return next_row  # type: ignore\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>The number of rows to fetch at a time with <code>.fetchmany()</code>.</p> <p>It defaults to 1 meaning to fetch a single row at a time.</p>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>The number of rows that the last <code>.execute*()</code> produced (for DQL statements like ) or affected (for DML statements like or ).</p> <p>The attribute is <code>-1</code> in case no <code>.execute*()</code> has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.execute","title":"<code>execute(operation, parameters=None)</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef execute(\n    self,\n    operation: str,\n    parameters: Optional[Parameters] = None,\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n    self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n    self._row_type = None\n\n    return self\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None)</code>","text":"<p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Cursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef execute_map(\n    self,\n    row_type: Type[turu.core.cursor.GenericNewRowType],\n    operation: str,\n    parameters: Optional[Parameters] = None,\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n    self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n    self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n    return self  # type: ignore\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: \"Optional[Parameters]\" = None,\n) -&gt; \"Cursor[Never]\":\n    return cast(Cursor, self.execute(operation, parameters))\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.executemany","title":"<code>executemany(operation, seq_of_parameters)</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef executemany(\n    self,\n    operation: str,\n    seq_of_parameters: Sequence[Parameters],\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n    self._raw_cursor.executemany(cast(LiteralString, operation), seq_of_parameters)\n    self._row_type = None\n\n    return self\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Cursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef executemany_map(\n    self,\n    row_type: Type[turu.core.cursor.GenericNewRowType],\n    operation: str,\n    seq_of_parameters: Sequence[Parameters],\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n    self._raw_cursor.executemany(cast(LiteralString, operation), seq_of_parameters)\n    self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: \"Sequence[Parameters]\",\n) -&gt; \"Cursor[Never]\":\n    return cast(Cursor, self.executemany(operation, seq_of_parameters))\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.fetchall","title":"<code>fetchall()</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef fetchall(self) -&gt; List[turu.core.cursor.GenericRowType]:\n    return [\n        turu.core.cursor.map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchall()\n    ]\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.fetchmany","title":"<code>fetchmany(size=None)</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef fetchmany(\n    self, size: Optional[int] = None\n) -&gt; List[turu.core.cursor.GenericRowType]:\n    return [\n        turu.core.cursor.map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchmany(\n            size if size is not None else self.arraysize\n        )\n    ]\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.Cursor.fetchone","title":"<code>fetchone()</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-mysql/src/turu/mysql/cursor.py</code> <pre><code>@override\ndef fetchone(self) -&gt; Optional[turu.core.cursor.GenericRowType]:\n    row = self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    elif self._row_type is not None:\n        return turu.core.cursor.map_row(self._row_type, row)\n\n    else:\n        return row  # type: ignore\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncConnection","title":"<code>turu.mysql.AsyncConnection</code>","text":"Source code in <code>turu-mysql/src/turu/mysql/async_connection.py</code> <pre><code>class AsyncConnection(turu.core.async_connection.AsyncConnection):\n    def __init__(self, connection: aiomysql.Connection):\n        self._raw_connection = connection\n\n    @override\n    @classmethod\n    async def connect(  # type: ignore[override]\n        cls,\n        user: Optional[str] = None,\n        password: str = \"\",\n        host: str = \"localhost\",\n        database: Optional[str] = None,\n        port: int = 0,\n        **kwargs: Unpack[\"_ConnectParams\"],\n    ) -&gt; Self:\n        return cls(\n            await aiomysql.connection._connect(\n                user=user,\n                password=password,\n                host=host,\n                db=database,\n                port=port,\n                **kwargs,\n            )\n        )\n\n    @override\n    @classmethod\n    async def connect_from_env(  # type: ignore[override]\n        cls,\n        user_envname: str = \"MYSQL_USER\",\n        password_envname: str = \"MYSQL_PASSWORD\",\n        host_envname: str = \"MYSQL_HOST\",\n        database_envname: str = \"MYSQL_DATABASE\",\n        port_envname: str = \"MYSQL_PORT\",\n        **kwargs: Unpack[\"_ConnectParams\"],\n    ) -&gt; Self:\n        return await cls.connect(\n            user=os.environ.get(user_envname),\n            password=os.environ.get(password_envname, \"\"),\n            host=os.environ.get(host_envname, \"localhost\"),\n            database=os.environ.get(database_envname),\n            port=int(os.environ.get(port_envname, 0)),\n            **kwargs,\n        )\n\n    @override\n    async def close(self) -&gt; None:\n        await self._raw_connection.ensure_closed()\n\n    @override\n    async def commit(self) -&gt; None:\n        await self._raw_connection.commit()\n\n    @override\n    async def rollback(self) -&gt; None:\n        await self._raw_connection.rollback()\n\n    @override\n    async def cursor(self) -&gt; AsyncCursor[Never]:\n        return AsyncCursor(\n            aiomysql.cursors.Cursor(\n                self._raw_connection,\n                self._raw_connection._echo,\n            )\n        )\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncConnection.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the connection now.</p> Source code in <code>turu-mysql/src/turu/mysql/async_connection.py</code> <pre><code>@override\nasync def close(self) -&gt; None:\n    await self._raw_connection.ensure_closed()\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncConnection.commit","title":"<code>commit()</code>  <code>async</code>","text":"<p>Commit any pending transaction to the database.</p> Source code in <code>turu-mysql/src/turu/mysql/async_connection.py</code> <pre><code>@override\nasync def commit(self) -&gt; None:\n    await self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncConnection.connect","title":"<code>connect(user=None, password='', host='localhost', database=None, port=0, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-mysql/src/turu/mysql/async_connection.py</code> <pre><code>@override\n@classmethod\nasync def connect(  # type: ignore[override]\n    cls,\n    user: Optional[str] = None,\n    password: str = \"\",\n    host: str = \"localhost\",\n    database: Optional[str] = None,\n    port: int = 0,\n    **kwargs: Unpack[\"_ConnectParams\"],\n) -&gt; Self:\n    return cls(\n        await aiomysql.connection._connect(\n            user=user,\n            password=password,\n            host=host,\n            db=database,\n            port=port,\n            **kwargs,\n        )\n    )\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncConnection.connect_from_env","title":"<code>connect_from_env(user_envname='MYSQL_USER', password_envname='MYSQL_PASSWORD', host_envname='MYSQL_HOST', database_envname='MYSQL_DATABASE', port_envname='MYSQL_PORT', **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-mysql/src/turu/mysql/async_connection.py</code> <pre><code>@override\n@classmethod\nasync def connect_from_env(  # type: ignore[override]\n    cls,\n    user_envname: str = \"MYSQL_USER\",\n    password_envname: str = \"MYSQL_PASSWORD\",\n    host_envname: str = \"MYSQL_HOST\",\n    database_envname: str = \"MYSQL_DATABASE\",\n    port_envname: str = \"MYSQL_PORT\",\n    **kwargs: Unpack[\"_ConnectParams\"],\n) -&gt; Self:\n    return await cls.connect(\n        user=os.environ.get(user_envname),\n        password=os.environ.get(password_envname, \"\"),\n        host=os.environ.get(host_envname, \"localhost\"),\n        database=os.environ.get(database_envname),\n        port=int(os.environ.get(port_envname, 0)),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncConnection.cursor","title":"<code>cursor()</code>  <code>async</code>","text":"<p>Return a new Cursor Object using the connection.</p> Source code in <code>turu-mysql/src/turu/mysql/async_connection.py</code> <pre><code>@override\nasync def cursor(self) -&gt; AsyncCursor[Never]:\n    return AsyncCursor(\n        aiomysql.cursors.Cursor(\n            self._raw_connection,\n            self._raw_connection._echo,\n        )\n    )\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncConnection.rollback","title":"<code>rollback()</code>  <code>async</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-mysql/src/turu/mysql/async_connection.py</code> <pre><code>@override\nasync def rollback(self) -&gt; None:\n    await self._raw_connection.rollback()\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor","title":"<code>turu.mysql.AsyncCursor</code>","text":"Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>class AsyncCursor(\n    turu.core.async_cursor.AsyncCursor[\n        turu.core.async_cursor.GenericRowType, Parameters\n    ],\n):\n    def __init__(\n        self,\n        cursor: aiomysql.Cursor,\n        *,\n        row_type: Optional[Type[turu.core.async_cursor.GenericRowType]] = None,\n    ):\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[turu.core.async_cursor.GenericRowType]] = row_type\n        self._aiter = None\n\n    @property\n    def rowcount(self) -&gt; int:\n        return self._raw_cursor.rowcount\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize\n\n    @arraysize.setter\n    def arraysize(self, size: int) -&gt; None:\n        self._raw_cursor.arraysize = size\n\n    @override\n    async def close(self) -&gt; None:\n        await self._raw_cursor.close()\n\n    @override\n    async def execute(\n        self, operation: str, parameters: Optional[Parameters] = None, /\n    ) -&gt; \"AsyncCursor[Tuple[Any]]\":\n        await self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n        self._row_type = None\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def executemany(\n        self, operation: str, seq_of_parameters: Sequence[Parameters], /\n    ) -&gt; \"AsyncCursor[Tuple[Any]]\":\n        await self._raw_cursor.executemany(\n            cast(LiteralString, operation), seq_of_parameters\n        )\n        self._row_type = None\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def execute_map(\n        self,\n        row_type: Type[turu.core.async_cursor.GenericNewRowType],\n        operation: str,\n        parameters: Optional[Parameters] = None,\n        /,\n    ) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n        await self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n        self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def executemany_map(\n        self,\n        row_type: Type[turu.core.async_cursor.GenericNewRowType],\n        operation: str,\n        seq_of_parameters: Sequence[Parameters],\n        /,\n    ) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n        await self._raw_cursor.executemany(\n            cast(LiteralString, operation), seq_of_parameters\n        )\n        self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: \"Optional[Parameters]\" = None,\n    ) -&gt; turu.core.async_cursor.AsyncCursor[Never, Parameters]:\n        return cast(\n            turu.core.async_cursor.AsyncCursor,\n            await self.execute(operation, parameters),\n        )\n\n    @override\n    async def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: Sequence[Parameters],\n    ) -&gt; turu.core.async_cursor.AsyncCursor[Never, Parameters]:\n        return cast(\n            turu.core.async_cursor.AsyncCursor,\n            await self.executemany(operation, seq_of_parameters),\n        )\n\n    @override\n    async def fetchone(self) -&gt; Optional[turu.core.async_cursor.GenericRowType]:\n        row = await self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        return _map_row(self._row_type, row)\n\n    @override\n    async def fetchmany(\n        self, size: Optional[int] = None\n    ) -&gt; List[turu.core.async_cursor.GenericRowType]:\n        return [\n            _map_row(self._row_type, row)\n            for row in (\n                await self._raw_cursor.fetchmany(\n                    size if size is not None else self.arraysize\n                )\n            )\n        ]\n\n    @override\n    async def fetchall(self) -&gt; List[turu.core.async_cursor.GenericRowType]:\n        return [\n            _map_row(self._row_type, row) for row in await self._raw_cursor.fetchall()\n        ]\n\n    @override\n    def __aiter__(self) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericRowType]\":\n        self._aiter = self._raw_cursor.__aiter__()\n        return self\n\n    @override\n    async def __anext__(self) -&gt; turu.core.async_cursor.GenericRowType:\n        if self._aiter is None:\n            self._aiter = self._raw_cursor.__aiter__()\n\n        next_row = await self._aiter.__anext__()\n        return _map_row(self._row_type, next_row)\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>This read/write attribute specifies the number of rows to fetch at a time with <code>.fetchmany()</code>. It defaults to 1 meaning to fetch a single row at a time.</p> <p>Implementations must observe this value with respect to the <code>.fetchmany()</code> method, but are free to interact with the database a single row at a time. It may also be used in the implementation of <code>.executemany()</code>.</p>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>the number of rows that the last .execute*() produced (for DQL statements like ) or affected (for DML statements like or ).</p> <p>The attribute is -1 in case no .execute*() has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.execute","title":"<code>execute(operation, parameters=None)</code>  <code>async</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def execute(\n    self, operation: str, parameters: Optional[Parameters] = None, /\n) -&gt; \"AsyncCursor[Tuple[Any]]\":\n    await self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n    self._row_type = None\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None)</code>  <code>async</code>","text":"<p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncCursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def execute_map(\n    self,\n    row_type: Type[turu.core.async_cursor.GenericNewRowType],\n    operation: str,\n    parameters: Optional[Parameters] = None,\n    /,\n) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n    await self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n    self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>  <code>async</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method executes an operation (Insert, Update, Delete) that does not return a value with a tag. This tag is used to verify that the specified operation is executed in order when testing with Mock.</p> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: \"Optional[Parameters]\" = None,\n) -&gt; turu.core.async_cursor.AsyncCursor[Never, Parameters]:\n    return cast(\n        turu.core.async_cursor.AsyncCursor,\n        await self.execute(operation, parameters),\n    )\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.executemany","title":"<code>executemany(operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def executemany(\n    self, operation: str, seq_of_parameters: Sequence[Parameters], /\n) -&gt; \"AsyncCursor[Tuple[Any]]\":\n    await self._raw_cursor.executemany(\n        cast(LiteralString, operation), seq_of_parameters\n    )\n    self._row_type = None\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>AsyncCursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def executemany_map(\n    self,\n    row_type: Type[turu.core.async_cursor.GenericNewRowType],\n    operation: str,\n    seq_of_parameters: Sequence[Parameters],\n    /,\n) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n    await self._raw_cursor.executemany(\n        cast(LiteralString, operation), seq_of_parameters\n    )\n    self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method executes an operation (Insert, Update, Delete) that does not return a value with a tag. This tag is used to verify that the specified operation is executed in order when testing with Mock.</p> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: Sequence[Parameters],\n) -&gt; turu.core.async_cursor.AsyncCursor[Never, Parameters]:\n    return cast(\n        turu.core.async_cursor.AsyncCursor,\n        await self.executemany(operation, seq_of_parameters),\n    )\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.fetchall","title":"<code>fetchall()</code>  <code>async</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def fetchall(self) -&gt; List[turu.core.async_cursor.GenericRowType]:\n    return [\n        _map_row(self._row_type, row) for row in await self._raw_cursor.fetchall()\n    ]\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.fetchmany","title":"<code>fetchmany(size=None)</code>  <code>async</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def fetchmany(\n    self, size: Optional[int] = None\n) -&gt; List[turu.core.async_cursor.GenericRowType]:\n    return [\n        _map_row(self._row_type, row)\n        for row in (\n            await self._raw_cursor.fetchmany(\n                size if size is not None else self.arraysize\n            )\n        )\n    ]\n</code></pre>"},{"location":"api/turu-mysql/#turu.mysql.AsyncCursor.fetchone","title":"<code>fetchone()</code>  <code>async</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-mysql/src/turu/mysql/async_cursor.py</code> <pre><code>@override\nasync def fetchone(self) -&gt; Optional[turu.core.async_cursor.GenericRowType]:\n    row = await self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    return _map_row(self._row_type, row)\n</code></pre>"},{"location":"api/turu-postgres/","title":"turu.postgres","text":""},{"location":"api/turu-postgres/#turu.postgres.Connection","title":"<code>turu.postgres.Connection</code>","text":"Source code in <code>turu-postgres/src/turu/postgres/connection.py</code> <pre><code>class Connection(turu.core.connection.Connection):\n    def __init__(self, connection: psycopg.Connection) -&gt; None:\n        self._raw_connection = connection\n\n    @override\n    @classmethod\n    def connect(  # type: ignore[override]\n        cls,\n        conninfo: str = \"\",\n        *,\n        autocommit: bool = False,\n        row_factory: Optional[psycopg.rows.RowFactory[psycopg.rows.Row]] = None,\n        prepare_threshold: Optional[int] = 5,\n        cursor_factory: Optional[Type[psycopg.Cursor[psycopg.rows.Row]]] = None,\n        context: Optional[psycopg.abc.AdaptContext] = None,\n        **kwargs: Union[None, int, str],\n    ) -&gt; Self:\n        return cls(\n            psycopg.connect(\n                conninfo,\n                autocommit=autocommit,\n                row_factory=row_factory,\n                prepare_threshold=prepare_threshold,\n                cursor_factory=cursor_factory,\n                context=context,\n                **kwargs,\n            )  # type: ignore\n        )\n\n    @override\n    @classmethod\n    def connect_from_env(  # type: ignore[override]\n        cls,\n        *,\n        dbname_envname=\"POSTGRES_DB\",\n        user_envname=\"POSTGRES_USER\",\n        password_envname=\"POSTGRES_PASSWORD\",\n        host_envname=\"POSTGRES_HOST\",\n        port_envname=\"POSTGRES_PORT\",\n        autocommit: bool = False,\n        row_factory: Optional[psycopg.rows.RowFactory[psycopg.rows.Row]] = None,\n        prepare_threshold: Optional[int] = 5,\n        cursor_factory: Optional[Type[psycopg.Cursor[psycopg.rows.Row]]] = None,\n        context: Optional[psycopg.abc.AdaptContext] = None,\n        **kwargs: Union[None, int, str],\n    ) -&gt; Self:\n        return cls.connect(\n            \"\\n\".join(\n                [\n                    f\"{key}={value}\"\n                    for key, value in {\n                        \"dbname\": os.environ.get(dbname_envname),\n                        \"user\": os.environ.get(user_envname),\n                        \"password\": os.environ.get(password_envname),\n                        \"host\": os.environ.get(host_envname),\n                        \"port\": os.environ.get(port_envname),\n                    }.items()\n                    if value is not None\n                ]\n            ),\n            autocommit=autocommit,\n            row_factory=row_factory,\n            prepare_threshold=prepare_threshold,\n            cursor_factory=cursor_factory,\n            context=context,\n            **kwargs,\n        )\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_connection.close()\n\n    @override\n    def commit(self) -&gt; None:\n        self._raw_connection.commit()\n\n    @override\n    def rollback(self) -&gt; None:\n        self._raw_connection.rollback()\n\n    @override\n    def cursor(self) -&gt; \"Cursor[Never]\":\n        return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Connection.close","title":"<code>close()</code>","text":"<p>Close the connection now.</p> Source code in <code>turu-postgres/src/turu/postgres/connection.py</code> <pre><code>@override\ndef close(self) -&gt; None:\n    self._raw_connection.close()\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Connection.commit","title":"<code>commit()</code>","text":"<p>Commit any pending transaction to the database.</p> Source code in <code>turu-postgres/src/turu/postgres/connection.py</code> <pre><code>@override\ndef commit(self) -&gt; None:\n    self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Connection.connect","title":"<code>connect(conninfo='', *, autocommit=False, row_factory=None, prepare_threshold=5, cursor_factory=None, context=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-postgres/src/turu/postgres/connection.py</code> <pre><code>@override\n@classmethod\ndef connect(  # type: ignore[override]\n    cls,\n    conninfo: str = \"\",\n    *,\n    autocommit: bool = False,\n    row_factory: Optional[psycopg.rows.RowFactory[psycopg.rows.Row]] = None,\n    prepare_threshold: Optional[int] = 5,\n    cursor_factory: Optional[Type[psycopg.Cursor[psycopg.rows.Row]]] = None,\n    context: Optional[psycopg.abc.AdaptContext] = None,\n    **kwargs: Union[None, int, str],\n) -&gt; Self:\n    return cls(\n        psycopg.connect(\n            conninfo,\n            autocommit=autocommit,\n            row_factory=row_factory,\n            prepare_threshold=prepare_threshold,\n            cursor_factory=cursor_factory,\n            context=context,\n            **kwargs,\n        )  # type: ignore\n    )\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Connection.connect_from_env","title":"<code>connect_from_env(*, dbname_envname='POSTGRES_DB', user_envname='POSTGRES_USER', password_envname='POSTGRES_PASSWORD', host_envname='POSTGRES_HOST', port_envname='POSTGRES_PORT', autocommit=False, row_factory=None, prepare_threshold=5, cursor_factory=None, context=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-postgres/src/turu/postgres/connection.py</code> <pre><code>@override\n@classmethod\ndef connect_from_env(  # type: ignore[override]\n    cls,\n    *,\n    dbname_envname=\"POSTGRES_DB\",\n    user_envname=\"POSTGRES_USER\",\n    password_envname=\"POSTGRES_PASSWORD\",\n    host_envname=\"POSTGRES_HOST\",\n    port_envname=\"POSTGRES_PORT\",\n    autocommit: bool = False,\n    row_factory: Optional[psycopg.rows.RowFactory[psycopg.rows.Row]] = None,\n    prepare_threshold: Optional[int] = 5,\n    cursor_factory: Optional[Type[psycopg.Cursor[psycopg.rows.Row]]] = None,\n    context: Optional[psycopg.abc.AdaptContext] = None,\n    **kwargs: Union[None, int, str],\n) -&gt; Self:\n    return cls.connect(\n        \"\\n\".join(\n            [\n                f\"{key}={value}\"\n                for key, value in {\n                    \"dbname\": os.environ.get(dbname_envname),\n                    \"user\": os.environ.get(user_envname),\n                    \"password\": os.environ.get(password_envname),\n                    \"host\": os.environ.get(host_envname),\n                    \"port\": os.environ.get(port_envname),\n                }.items()\n                if value is not None\n            ]\n        ),\n        autocommit=autocommit,\n        row_factory=row_factory,\n        prepare_threshold=prepare_threshold,\n        cursor_factory=cursor_factory,\n        context=context,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Connection.cursor","title":"<code>cursor()</code>","text":"<p>Return a new Cursor Object using the connection.</p> Source code in <code>turu-postgres/src/turu/postgres/connection.py</code> <pre><code>@override\ndef cursor(self) -&gt; \"Cursor[Never]\":\n    return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Connection.rollback","title":"<code>rollback()</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-postgres/src/turu/postgres/connection.py</code> <pre><code>@override\ndef rollback(self) -&gt; None:\n    self._raw_connection.rollback()\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor","title":"<code>turu.postgres.Cursor</code>","text":"Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>class Cursor(\n    turu.core.cursor.Cursor[turu.core.cursor.GenericRowType, Parameters],\n):\n    def __init__(\n        self,\n        cursor: psycopg.Cursor,\n        *,\n        row_type: Optional[Type[turu.core.cursor.GenericRowType]] = None,\n    ):\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[turu.core.cursor.GenericRowType]] = row_type\n        self._iter = None\n\n    @property\n    def rowcount(self) -&gt; int:\n        return self._raw_cursor.rowcount\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize\n\n    @arraysize.setter\n    def arraysize(self, size: int) -&gt; None:\n        self._raw_cursor.arraysize = size\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_cursor.close()\n\n    @override\n    def execute(\n        self,\n        operation: str,\n        parameters: Optional[Parameters] = None,\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n        self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n        self._row_type = None\n\n        return self\n\n    @override\n    def executemany(\n        self,\n        operation: str,\n        seq_of_parameters: Sequence[Parameters],\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n        self._raw_cursor.executemany(cast(LiteralString, operation), seq_of_parameters)\n        self._row_type = None\n\n        return self\n\n    @override\n    def execute_map(\n        self,\n        row_type: Type[turu.core.cursor.GenericNewRowType],\n        operation: str,\n        parameters: Optional[Parameters] = None,\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n        self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n        self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @override\n    def executemany_map(\n        self,\n        row_type: Type[turu.core.cursor.GenericNewRowType],\n        operation: str,\n        seq_of_parameters: Sequence[Parameters],\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n        self._raw_cursor.executemany(cast(LiteralString, operation), seq_of_parameters)\n        self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @override\n    def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: \"Optional[Parameters]\" = None,\n    ) -&gt; \"Cursor[Never]\":\n        return cast(Cursor, self.execute(operation, parameters))\n\n    @override\n    def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: \"Sequence[Parameters]\",\n    ) -&gt; \"Cursor[Never]\":\n        return cast(Cursor, self.executemany(operation, seq_of_parameters))\n\n    @override\n    def fetchone(self) -&gt; Optional[turu.core.cursor.GenericRowType]:\n        row = self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        elif self._row_type is not None:\n            return turu.core.cursor.map_row(self._row_type, row)\n\n        else:\n            return row  # type: ignore\n\n    @override\n    def fetchmany(\n        self, size: Optional[int] = None\n    ) -&gt; List[turu.core.cursor.GenericRowType]:\n        return [\n            turu.core.cursor.map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchmany(\n                size if size is not None else self.arraysize\n            )\n        ]\n\n    @override\n    def fetchall(self) -&gt; List[turu.core.cursor.GenericRowType]:\n        return [\n            turu.core.cursor.map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchall()\n        ]\n\n    @override\n    def __iter__(self) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n        self._iter = self._raw_cursor.__iter__()\n        return self\n\n    @override\n    def __next__(self) -&gt; turu.core.cursor.GenericRowType:\n        if self._iter is None:\n            self._iter = self._raw_cursor.__iter__()\n\n        next_row = next(self._iter)\n        if self._row_type is not None and next_row is not None:\n            return turu.core.cursor.map_row(self._row_type, next_row)\n\n        else:\n            return next_row  # type: ignore\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>The number of rows to fetch at a time with <code>.fetchmany()</code>.</p> <p>It defaults to 1 meaning to fetch a single row at a time.</p>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>The number of rows that the last <code>.execute*()</code> produced (for DQL statements like ) or affected (for DML statements like or ).</p> <p>The attribute is <code>-1</code> in case no <code>.execute*()</code> has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.execute","title":"<code>execute(operation, parameters=None)</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef execute(\n    self,\n    operation: str,\n    parameters: Optional[Parameters] = None,\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n    self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n    self._row_type = None\n\n    return self\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None)</code>","text":"<p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Cursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef execute_map(\n    self,\n    row_type: Type[turu.core.cursor.GenericNewRowType],\n    operation: str,\n    parameters: Optional[Parameters] = None,\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n    self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n    self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: \"Optional[Parameters]\" = None,\n) -&gt; \"Cursor[Never]\":\n    return cast(Cursor, self.execute(operation, parameters))\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.executemany","title":"<code>executemany(operation, seq_of_parameters)</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef executemany(\n    self,\n    operation: str,\n    seq_of_parameters: Sequence[Parameters],\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericRowType]\":\n    self._raw_cursor.executemany(cast(LiteralString, operation), seq_of_parameters)\n    self._row_type = None\n\n    return self\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Cursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef executemany_map(\n    self,\n    row_type: Type[turu.core.cursor.GenericNewRowType],\n    operation: str,\n    seq_of_parameters: Sequence[Parameters],\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n    self._raw_cursor.executemany(cast(LiteralString, operation), seq_of_parameters)\n    self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: \"Sequence[Parameters]\",\n) -&gt; \"Cursor[Never]\":\n    return cast(Cursor, self.executemany(operation, seq_of_parameters))\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.fetchall","title":"<code>fetchall()</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef fetchall(self) -&gt; List[turu.core.cursor.GenericRowType]:\n    return [\n        turu.core.cursor.map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchall()\n    ]\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.fetchmany","title":"<code>fetchmany(size=None)</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef fetchmany(\n    self, size: Optional[int] = None\n) -&gt; List[turu.core.cursor.GenericRowType]:\n    return [\n        turu.core.cursor.map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchmany(\n            size if size is not None else self.arraysize\n        )\n    ]\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.Cursor.fetchone","title":"<code>fetchone()</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-postgres/src/turu/postgres/cursor.py</code> <pre><code>@override\ndef fetchone(self) -&gt; Optional[turu.core.cursor.GenericRowType]:\n    row = self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    elif self._row_type is not None:\n        return turu.core.cursor.map_row(self._row_type, row)\n\n    else:\n        return row  # type: ignore\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncConnection","title":"<code>turu.postgres.AsyncConnection</code>","text":"Source code in <code>turu-postgres/src/turu/postgres/async_connection.py</code> <pre><code>class AsyncConnection(turu.core.async_connection.AsyncConnection):\n    def __init__(self, connection: psycopg.AsyncConnection):\n        self._raw_connection = connection\n\n    @override\n    @classmethod\n    async def connect(  # type: ignore[override]\n        cls,\n        conninfo: str = \"\",\n        *,\n        autocommit: bool = False,\n        row_factory: Optional[psycopg.rows.AsyncRowFactory[psycopg.rows.Row]] = None,\n        prepare_threshold: Optional[int] = 5,\n        cursor_factory: Optional[Type[psycopg.AsyncCursor[psycopg.rows.Row]]] = None,\n        context: Optional[psycopg.abc.AdaptContext] = None,\n        **kwargs: Optional[Union[int, str]],\n    ) -&gt; Self:\n        return cls(\n            await psycopg.AsyncConnection.connect(\n                conninfo,\n                autocommit=autocommit,\n                prepare_threshold=prepare_threshold,\n                row_factory=row_factory,\n                cursor_factory=cursor_factory,\n                context=context,\n                **kwargs,\n            )  # type: ignore\n        )\n\n    @override\n    @classmethod\n    async def connect_from_env(  # type: ignore[override]\n        cls,\n        *,\n        autocommit: bool = False,\n        row_factory: Optional[psycopg.rows.AsyncRowFactory[psycopg.rows.Row]] = None,\n        prepare_threshold: Optional[int] = 5,\n        cursor_factory: Optional[Type[psycopg.AsyncCursor[psycopg.rows.Row]]] = None,\n        context: Optional[psycopg.abc.AdaptContext] = None,\n        dbname_envname=\"POSTGRES_DB\",\n        user_envname=\"POSTGRES_USER\",\n        password_envname=\"POSTGRES_PASSWORD\",\n        host_envname=\"POSTGRES_HOST\",\n        port_envname=\"POSTGRES_PORT\",\n        **kwargs: Union[None, int, str],\n    ):\n        return await cls.connect(\n            \"\\n\".join(\n                [\n                    f\"{key}={value}\"\n                    for key, value in {\n                        \"dbname\": os.environ.get(dbname_envname),\n                        \"user\": os.environ.get(user_envname),\n                        \"password\": os.environ.get(password_envname),\n                        \"host\": os.environ.get(host_envname),\n                        \"port\": os.environ.get(port_envname),\n                    }.items()\n                    if value is not None\n                ]\n            ),\n            autocommit=autocommit,\n            row_factory=row_factory,\n            prepare_threshold=prepare_threshold,\n            cursor_factory=cursor_factory,\n            context=context,\n            **kwargs,\n        )\n\n    @override\n    async def close(self) -&gt; None:\n        await self._raw_connection.close()\n\n    @override\n    async def commit(self) -&gt; None:\n        await self._raw_connection.commit()\n\n    @override\n    async def rollback(self) -&gt; None:\n        await self._raw_connection.rollback()\n\n    @override\n    async def cursor(self) -&gt; AsyncCursor[Never]:\n        return AsyncCursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncConnection.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the connection now.</p> Source code in <code>turu-postgres/src/turu/postgres/async_connection.py</code> <pre><code>@override\nasync def close(self) -&gt; None:\n    await self._raw_connection.close()\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncConnection.commit","title":"<code>commit()</code>  <code>async</code>","text":"<p>Commit any pending transaction to the database.</p> Source code in <code>turu-postgres/src/turu/postgres/async_connection.py</code> <pre><code>@override\nasync def commit(self) -&gt; None:\n    await self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncConnection.connect","title":"<code>connect(conninfo='', *, autocommit=False, row_factory=None, prepare_threshold=5, cursor_factory=None, context=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-postgres/src/turu/postgres/async_connection.py</code> <pre><code>@override\n@classmethod\nasync def connect(  # type: ignore[override]\n    cls,\n    conninfo: str = \"\",\n    *,\n    autocommit: bool = False,\n    row_factory: Optional[psycopg.rows.AsyncRowFactory[psycopg.rows.Row]] = None,\n    prepare_threshold: Optional[int] = 5,\n    cursor_factory: Optional[Type[psycopg.AsyncCursor[psycopg.rows.Row]]] = None,\n    context: Optional[psycopg.abc.AdaptContext] = None,\n    **kwargs: Optional[Union[int, str]],\n) -&gt; Self:\n    return cls(\n        await psycopg.AsyncConnection.connect(\n            conninfo,\n            autocommit=autocommit,\n            prepare_threshold=prepare_threshold,\n            row_factory=row_factory,\n            cursor_factory=cursor_factory,\n            context=context,\n            **kwargs,\n        )  # type: ignore\n    )\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncConnection.connect_from_env","title":"<code>connect_from_env(*, autocommit=False, row_factory=None, prepare_threshold=5, cursor_factory=None, context=None, dbname_envname='POSTGRES_DB', user_envname='POSTGRES_USER', password_envname='POSTGRES_PASSWORD', host_envname='POSTGRES_HOST', port_envname='POSTGRES_PORT', **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-postgres/src/turu/postgres/async_connection.py</code> <pre><code>@override\n@classmethod\nasync def connect_from_env(  # type: ignore[override]\n    cls,\n    *,\n    autocommit: bool = False,\n    row_factory: Optional[psycopg.rows.AsyncRowFactory[psycopg.rows.Row]] = None,\n    prepare_threshold: Optional[int] = 5,\n    cursor_factory: Optional[Type[psycopg.AsyncCursor[psycopg.rows.Row]]] = None,\n    context: Optional[psycopg.abc.AdaptContext] = None,\n    dbname_envname=\"POSTGRES_DB\",\n    user_envname=\"POSTGRES_USER\",\n    password_envname=\"POSTGRES_PASSWORD\",\n    host_envname=\"POSTGRES_HOST\",\n    port_envname=\"POSTGRES_PORT\",\n    **kwargs: Union[None, int, str],\n):\n    return await cls.connect(\n        \"\\n\".join(\n            [\n                f\"{key}={value}\"\n                for key, value in {\n                    \"dbname\": os.environ.get(dbname_envname),\n                    \"user\": os.environ.get(user_envname),\n                    \"password\": os.environ.get(password_envname),\n                    \"host\": os.environ.get(host_envname),\n                    \"port\": os.environ.get(port_envname),\n                }.items()\n                if value is not None\n            ]\n        ),\n        autocommit=autocommit,\n        row_factory=row_factory,\n        prepare_threshold=prepare_threshold,\n        cursor_factory=cursor_factory,\n        context=context,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncConnection.cursor","title":"<code>cursor()</code>  <code>async</code>","text":"<p>Return a new Cursor Object using the connection.</p> Source code in <code>turu-postgres/src/turu/postgres/async_connection.py</code> <pre><code>@override\nasync def cursor(self) -&gt; AsyncCursor[Never]:\n    return AsyncCursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncConnection.rollback","title":"<code>rollback()</code>  <code>async</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-postgres/src/turu/postgres/async_connection.py</code> <pre><code>@override\nasync def rollback(self) -&gt; None:\n    await self._raw_connection.rollback()\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor","title":"<code>turu.postgres.AsyncCursor</code>","text":"Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>class AsyncCursor(\n    turu.core.async_cursor.AsyncCursor[\n        turu.core.async_cursor.GenericRowType, Parameters\n    ],\n):\n    def __init__(\n        self,\n        cursor: psycopg.AsyncCursor,\n        *,\n        row_type: Optional[Type[turu.core.async_cursor.GenericRowType]] = None,\n    ):\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[turu.core.async_cursor.GenericRowType]] = row_type\n        self._aiter = None\n\n    @property\n    def rowcount(self) -&gt; int:\n        return self._raw_cursor.rowcount\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize\n\n    @arraysize.setter\n    def arraysize(self, size: int) -&gt; None:\n        self._raw_cursor.arraysize = size\n\n    @override\n    async def close(self) -&gt; None:\n        await self._raw_cursor.close()\n\n    @override\n    async def execute(\n        self, operation: str, parameters: Optional[Parameters] = None, /\n    ) -&gt; \"AsyncCursor[Tuple[Any]]\":\n        await self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n        self._row_type = None\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def executemany(\n        self, operation: str, seq_of_parameters: Sequence[Parameters], /\n    ) -&gt; \"AsyncCursor[Tuple[Any]]\":\n        await self._raw_cursor.executemany(\n            cast(LiteralString, operation), seq_of_parameters\n        )\n        self._row_type = None\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def execute_map(\n        self,\n        row_type: Type[turu.core.async_cursor.GenericNewRowType],\n        operation: str,\n        parameters: Optional[Parameters] = None,\n        /,\n    ) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n        await self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n        self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def executemany_map(\n        self,\n        row_type: Type[turu.core.async_cursor.GenericNewRowType],\n        operation: str,\n        seq_of_parameters: Sequence[Parameters],\n        /,\n    ) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n        await self._raw_cursor.executemany(\n            cast(LiteralString, operation), seq_of_parameters\n        )\n        self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: \"Optional[Parameters]\" = None,\n    ) -&gt; turu.core.async_cursor.AsyncCursor[Never, Parameters]:\n        return cast(\n            turu.core.async_cursor.AsyncCursor,\n            await self.execute(operation, parameters),\n        )\n\n    @override\n    async def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: Sequence[Parameters],\n    ) -&gt; turu.core.async_cursor.AsyncCursor[Never, Parameters]:\n        return cast(\n            turu.core.async_cursor.AsyncCursor,\n            await self.executemany(operation, seq_of_parameters),\n        )\n\n    @override\n    async def fetchone(self) -&gt; Optional[turu.core.async_cursor.GenericRowType]:\n        row = await self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        return _map_row(self._row_type, row)\n\n    @override\n    async def fetchmany(\n        self, size: Optional[int] = None\n    ) -&gt; List[turu.core.async_cursor.GenericRowType]:\n        return [\n            _map_row(self._row_type, row)\n            for row in (\n                await self._raw_cursor.fetchmany(\n                    size if size is not None else self.arraysize\n                )\n            )\n        ]\n\n    @override\n    async def fetchall(self) -&gt; List[turu.core.async_cursor.GenericRowType]:\n        return [\n            _map_row(self._row_type, row) for row in await self._raw_cursor.fetchall()\n        ]\n\n    @override\n    def __aiter__(self) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericRowType]\":\n        self._aiter = self._raw_cursor.__aiter__()\n        return self\n\n    @override\n    async def __anext__(self) -&gt; turu.core.async_cursor.GenericRowType:\n        if self._aiter is None:\n            self._aiter = self._raw_cursor.__aiter__()\n\n        next_row = await self._aiter.__anext__()\n        return _map_row(self._row_type, next_row)\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>This read/write attribute specifies the number of rows to fetch at a time with <code>.fetchmany()</code>. It defaults to 1 meaning to fetch a single row at a time.</p> <p>Implementations must observe this value with respect to the <code>.fetchmany()</code> method, but are free to interact with the database a single row at a time. It may also be used in the implementation of <code>.executemany()</code>.</p>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>the number of rows that the last .execute*() produced (for DQL statements like ) or affected (for DML statements like or ).</p> <p>The attribute is -1 in case no .execute*() has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.execute","title":"<code>execute(operation, parameters=None)</code>  <code>async</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def execute(\n    self, operation: str, parameters: Optional[Parameters] = None, /\n) -&gt; \"AsyncCursor[Tuple[Any]]\":\n    await self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n    self._row_type = None\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None)</code>  <code>async</code>","text":"<p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncCursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def execute_map(\n    self,\n    row_type: Type[turu.core.async_cursor.GenericNewRowType],\n    operation: str,\n    parameters: Optional[Parameters] = None,\n    /,\n) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n    await self._raw_cursor.execute(cast(LiteralString, operation), parameters)\n    self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>  <code>async</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method executes an operation (Insert, Update, Delete) that does not return a value with a tag. This tag is used to verify that the specified operation is executed in order when testing with Mock.</p> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: \"Optional[Parameters]\" = None,\n) -&gt; turu.core.async_cursor.AsyncCursor[Never, Parameters]:\n    return cast(\n        turu.core.async_cursor.AsyncCursor,\n        await self.execute(operation, parameters),\n    )\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.executemany","title":"<code>executemany(operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def executemany(\n    self, operation: str, seq_of_parameters: Sequence[Parameters], /\n) -&gt; \"AsyncCursor[Tuple[Any]]\":\n    await self._raw_cursor.executemany(\n        cast(LiteralString, operation), seq_of_parameters\n    )\n    self._row_type = None\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>AsyncCursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def executemany_map(\n    self,\n    row_type: Type[turu.core.async_cursor.GenericNewRowType],\n    operation: str,\n    seq_of_parameters: Sequence[Parameters],\n    /,\n) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n    await self._raw_cursor.executemany(\n        cast(LiteralString, operation), seq_of_parameters\n    )\n    self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method executes an operation (Insert, Update, Delete) that does not return a value with a tag. This tag is used to verify that the specified operation is executed in order when testing with Mock.</p> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: Sequence[Parameters],\n) -&gt; turu.core.async_cursor.AsyncCursor[Never, Parameters]:\n    return cast(\n        turu.core.async_cursor.AsyncCursor,\n        await self.executemany(operation, seq_of_parameters),\n    )\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.fetchall","title":"<code>fetchall()</code>  <code>async</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def fetchall(self) -&gt; List[turu.core.async_cursor.GenericRowType]:\n    return [\n        _map_row(self._row_type, row) for row in await self._raw_cursor.fetchall()\n    ]\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.fetchmany","title":"<code>fetchmany(size=None)</code>  <code>async</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def fetchmany(\n    self, size: Optional[int] = None\n) -&gt; List[turu.core.async_cursor.GenericRowType]:\n    return [\n        _map_row(self._row_type, row)\n        for row in (\n            await self._raw_cursor.fetchmany(\n                size if size is not None else self.arraysize\n            )\n        )\n    ]\n</code></pre>"},{"location":"api/turu-postgres/#turu.postgres.AsyncCursor.fetchone","title":"<code>fetchone()</code>  <code>async</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-postgres/src/turu/postgres/async_cursor.py</code> <pre><code>@override\nasync def fetchone(self) -&gt; Optional[turu.core.async_cursor.GenericRowType]:\n    row = await self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    return _map_row(self._row_type, row)\n</code></pre>"},{"location":"api/turu-snowflake/","title":"turu.snowflake","text":""},{"location":"api/turu-snowflake/#turu.snowflake.Connection","title":"<code>turu.snowflake.Connection</code>","text":"<p>A connection to a Snowflake database.</p> <p>This class is a wrapper around the <code>snowflake.connector.SnowflakeConnection</code> class.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>class Connection(turu.core.connection.Connection):\n    \"\"\"\n    A connection to a Snowflake database.\n\n    This class is a wrapper around the `snowflake.connector.SnowflakeConnection` class.\n    \"\"\"\n\n    def __init__(self, connection: snowflake.connector.SnowflakeConnection):\n        self._raw_connection = connection\n\n    @override\n    @classmethod\n    def connect(  # type: ignore[override]\n        cls,\n        connection_name: Optional[str] = None,\n        connections_file_path: Optional[Path] = None,\n        user: Optional[str] = None,\n        password: Optional[str] = None,\n        account: Optional[str] = None,\n        database: Optional[str] = None,\n        schema: Optional[str] = None,\n        warehouse: Optional[str] = None,\n        role: Optional[str] = None,\n        private_key: \"Union[str ,bytes ,RSAPrivateKey, None]\" = None,\n        private_key_file: Union[str, Path, None] = None,\n        private_key_passphrase: Union[str, bytes, None] = None,\n        **kwargs,\n    ) -&gt; Self:\n        if isinstance(private_key_file, (str, Path)):\n            with open(private_key_file, \"rb\") as key:\n                private_key = key.read()\n        elif isinstance(private_key, str):\n            private_key = private_key.encode(\"utf-8\")\n\n        if isinstance(private_key, bytes):\n            from turu.snowflake._key_pair import load_private_key\n\n            if isinstance(private_key_passphrase, str):\n                private_key_passphrase = private_key_passphrase.encode(\"utf-8\")\n\n            private_key = load_private_key(private_key, private_key_passphrase)\n\n        return cls(\n            snowflake.connector.SnowflakeConnection(\n                connection_name,\n                connections_file_path,\n                user=user,\n                password=password,\n                account=account,\n                database=database,\n                schema=schema,\n                warehouse=warehouse,\n                role=role,\n                private_key=private_key,\n                **kwargs,\n            )\n        )\n\n    @override\n    @classmethod\n    def connect_from_env(  # type: ignore[override]\n        cls,\n        connection_name: Optional[str] = None,\n        connections_file_path: Optional[Path] = None,\n        user_envname: str = \"SNOWFLAKE_USER\",\n        password_envname: str = \"SNOWFLAKE_PASSWORD\",\n        account_envname: str = \"SNOWFLAKE_ACCOUNT\",\n        database_envname: str = \"SNOWFLAKE_DATABASE\",\n        schema_envname: str = \"SNOWFLAKE_SCHEMA\",\n        warehouse_envname: str = \"SNOWFLAKE_WAREHOUSE\",\n        role_envname: str = \"SNOWFLAKE_ROLE\",\n        authenticator_envname: str = \"SNOWFLAKE_AUTHENTICATOR\",\n        private_key_envname: str = \"SNOWFLAKE_PRIVATE_KEY\",\n        private_key_file_envname: str = \"SNOWFLAKE_PRIVATE_KEY_FILE\",\n        private_key_passphrase_envname: str = \"SNOWFLAKE_PRIVATE_KEY_PASSPHRASE\",\n        **kwargs: Any,\n    ) -&gt; Self:\n        if (\n            authenticator := os.environ.get(\n                authenticator_envname,\n                kwargs.get(\"authenticator\"),\n            )\n        ) and \"authenticator\" not in kwargs:\n            kwargs[\"authenticator\"] = authenticator\n\n        return cls.connect(\n            connection_name,\n            connections_file_path,\n            user=kwargs.pop(\"user\", os.environ.get(user_envname)),\n            password=kwargs.pop(\"password\", os.environ.get(password_envname)),\n            account=kwargs.pop(\"account\", os.environ.get(account_envname)),\n            database=kwargs.pop(\"database\", os.environ.get(database_envname)),\n            schema=kwargs.pop(\"schema\", os.environ.get(schema_envname)),\n            warehouse=kwargs.pop(\"warehouse\", os.environ.get(warehouse_envname)),\n            role=kwargs.pop(\"role\", os.environ.get(role_envname)),\n            private_key=kwargs.pop(\"private_key\", os.environ.get(private_key_envname)),\n            private_key_file=kwargs.pop(\n                \"private_key_file\", os.environ.get(private_key_file_envname)\n            ),\n            private_key_passphrase=kwargs.pop(\n                \"private_key_passphrase\", os.environ.get(private_key_passphrase_envname)\n            ),\n            **kwargs,\n        )\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_connection.close()\n\n    @override\n    def commit(self) -&gt; None:\n        self._raw_connection.commit()\n\n    @override\n    def rollback(self) -&gt; None:\n        self._raw_connection.rollback()\n\n    @override\n    def cursor(self) -&gt; Cursor[Never, Never, Never]:\n        return Cursor(self._raw_connection.cursor())\n\n    @override\n    def execute(\n        self,\n        operation: str,\n        parameters: Optional[Any] = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]:\n        \"\"\"Prepare and execute a database operation (query or command).\n\n        This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n        but is simply a convenient shortcut to `.cursor().execute()`.\n\n        Parameters:\n            operation: A database operation (query or command).\n            parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        return self.cursor().execute(operation, parameters, **options)\n\n    @override\n    def executemany(\n        self,\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]:\n        \"\"\"Prepare a database operation (query or command)\n        and then execute it against all parameter sequences or mappings.\n\n        This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n        but is simply a convenient shortcut to `.cursor().executemany()`.\n\n        Parameters:\n            operation: A database operation (query or command).\n            seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        return self.cursor().executemany(operation, seq_of_parameters, **options)\n\n    @overload\n    def execute_map(\n        self,\n        row_type: Type[GenericNewRowType],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[GenericNewRowType, Never, Never]: ...\n\n    @overload\n    def execute_map(\n        self,\n        row_type: Type[GenericNewPandasDataFrame],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[Never, GenericNewPandasDataFrame, Never]: ...\n\n    @overload\n    def execute_map(\n        self,\n        row_type: Type[GenericNewPyArrowTable],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[Never, Never, GenericNewPyArrowTable]: ...\n\n    @overload\n    def execute_map(\n        self,\n        row_type: Type[GenericNewPanderaDataFrameModel],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]: ...\n\n    @override\n    def execute_map(\n        self,\n        row_type: Union[\n            Type[GenericNewRowType],\n            Type[GenericNewPandasDataFrame],\n            Type[GenericNewPyArrowTable],\n            Type[GenericNewPanderaDataFrameModel],\n        ],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor:\n        \"\"\"\n        Execute a database operation (query or command) and map each row to a `row_type`.\n\n        This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n        but is simply a convenient shortcut to `.cursor().execute_map()`.\n\n        Parameters:\n            row_type: The type of the row that will be returned.\n            operation: A database operation (query or command).\n            parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        return cast(\n            Cursor,\n            self.cursor().execute_map(\n                row_type,\n                operation,\n                parameters,\n                **options,\n            ),\n        )\n\n    @overload\n    def executemany_map(\n        self,\n        row_type: Type[GenericNewRowType],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[GenericNewRowType, Never, Never]: ...\n\n    @overload\n    def executemany_map(\n        self,\n        row_type: Type[GenericNewPandasDataFrame],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[Never, GenericNewPandasDataFrame, Never]: ...\n\n    @overload\n    def executemany_map(\n        self,\n        row_type: Type[GenericNewPyArrowTable],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[Never, Never, GenericNewPyArrowTable]: ...\n\n    @overload\n    def executemany_map(\n        self,\n        row_type: Type[GenericNewPanderaDataFrameModel],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]: ...\n\n    @override\n    def executemany_map(\n        self,\n        row_type: Union[\n            Type[GenericNewRowType],\n            Type[GenericNewPandasDataFrame],\n            Type[GenericNewPyArrowTable],\n            Type[GenericNewPanderaDataFrameModel],\n        ],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; Cursor:\n        \"\"\"Execute a database operation (query or command) against all parameter sequences or mappings.\n\n        This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n        but is simply a convenient shortcut to `.cursor().executemany_map()`.\n\n        Parameters:\n            row_type: The type of the row that will be returned.\n            operation: A database operation (query or command).\n            seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        return cast(\n            Cursor,\n            self.cursor().executemany_map(\n                row_type, operation, seq_of_parameters, **options\n            ),\n        )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.close","title":"<code>close()</code>","text":"<p>Close the connection now.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\ndef close(self) -&gt; None:\n    self._raw_connection.close()\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.commit","title":"<code>commit()</code>","text":"<p>Commit any pending transaction to the database.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\ndef commit(self) -&gt; None:\n    self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.connect","title":"<code>connect(connection_name=None, connections_file_path=None, user=None, password=None, account=None, database=None, schema=None, warehouse=None, role=None, private_key=None, private_key_file=None, private_key_passphrase=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\n@classmethod\ndef connect(  # type: ignore[override]\n    cls,\n    connection_name: Optional[str] = None,\n    connections_file_path: Optional[Path] = None,\n    user: Optional[str] = None,\n    password: Optional[str] = None,\n    account: Optional[str] = None,\n    database: Optional[str] = None,\n    schema: Optional[str] = None,\n    warehouse: Optional[str] = None,\n    role: Optional[str] = None,\n    private_key: \"Union[str ,bytes ,RSAPrivateKey, None]\" = None,\n    private_key_file: Union[str, Path, None] = None,\n    private_key_passphrase: Union[str, bytes, None] = None,\n    **kwargs,\n) -&gt; Self:\n    if isinstance(private_key_file, (str, Path)):\n        with open(private_key_file, \"rb\") as key:\n            private_key = key.read()\n    elif isinstance(private_key, str):\n        private_key = private_key.encode(\"utf-8\")\n\n    if isinstance(private_key, bytes):\n        from turu.snowflake._key_pair import load_private_key\n\n        if isinstance(private_key_passphrase, str):\n            private_key_passphrase = private_key_passphrase.encode(\"utf-8\")\n\n        private_key = load_private_key(private_key, private_key_passphrase)\n\n    return cls(\n        snowflake.connector.SnowflakeConnection(\n            connection_name,\n            connections_file_path,\n            user=user,\n            password=password,\n            account=account,\n            database=database,\n            schema=schema,\n            warehouse=warehouse,\n            role=role,\n            private_key=private_key,\n            **kwargs,\n        )\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.connect_from_env","title":"<code>connect_from_env(connection_name=None, connections_file_path=None, user_envname='SNOWFLAKE_USER', password_envname='SNOWFLAKE_PASSWORD', account_envname='SNOWFLAKE_ACCOUNT', database_envname='SNOWFLAKE_DATABASE', schema_envname='SNOWFLAKE_SCHEMA', warehouse_envname='SNOWFLAKE_WAREHOUSE', role_envname='SNOWFLAKE_ROLE', authenticator_envname='SNOWFLAKE_AUTHENTICATOR', private_key_envname='SNOWFLAKE_PRIVATE_KEY', private_key_file_envname='SNOWFLAKE_PRIVATE_KEY_FILE', private_key_passphrase_envname='SNOWFLAKE_PRIVATE_KEY_PASSPHRASE', **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\n@classmethod\ndef connect_from_env(  # type: ignore[override]\n    cls,\n    connection_name: Optional[str] = None,\n    connections_file_path: Optional[Path] = None,\n    user_envname: str = \"SNOWFLAKE_USER\",\n    password_envname: str = \"SNOWFLAKE_PASSWORD\",\n    account_envname: str = \"SNOWFLAKE_ACCOUNT\",\n    database_envname: str = \"SNOWFLAKE_DATABASE\",\n    schema_envname: str = \"SNOWFLAKE_SCHEMA\",\n    warehouse_envname: str = \"SNOWFLAKE_WAREHOUSE\",\n    role_envname: str = \"SNOWFLAKE_ROLE\",\n    authenticator_envname: str = \"SNOWFLAKE_AUTHENTICATOR\",\n    private_key_envname: str = \"SNOWFLAKE_PRIVATE_KEY\",\n    private_key_file_envname: str = \"SNOWFLAKE_PRIVATE_KEY_FILE\",\n    private_key_passphrase_envname: str = \"SNOWFLAKE_PRIVATE_KEY_PASSPHRASE\",\n    **kwargs: Any,\n) -&gt; Self:\n    if (\n        authenticator := os.environ.get(\n            authenticator_envname,\n            kwargs.get(\"authenticator\"),\n        )\n    ) and \"authenticator\" not in kwargs:\n        kwargs[\"authenticator\"] = authenticator\n\n    return cls.connect(\n        connection_name,\n        connections_file_path,\n        user=kwargs.pop(\"user\", os.environ.get(user_envname)),\n        password=kwargs.pop(\"password\", os.environ.get(password_envname)),\n        account=kwargs.pop(\"account\", os.environ.get(account_envname)),\n        database=kwargs.pop(\"database\", os.environ.get(database_envname)),\n        schema=kwargs.pop(\"schema\", os.environ.get(schema_envname)),\n        warehouse=kwargs.pop(\"warehouse\", os.environ.get(warehouse_envname)),\n        role=kwargs.pop(\"role\", os.environ.get(role_envname)),\n        private_key=kwargs.pop(\"private_key\", os.environ.get(private_key_envname)),\n        private_key_file=kwargs.pop(\n            \"private_key_file\", os.environ.get(private_key_file_envname)\n        ),\n        private_key_passphrase=kwargs.pop(\n            \"private_key_passphrase\", os.environ.get(private_key_passphrase_envname)\n        ),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.cursor","title":"<code>cursor()</code>","text":"<p>Return a new Cursor Object using the connection.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\ndef cursor(self) -&gt; Cursor[Never, Never, Never]:\n    return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.execute","title":"<code>execute(operation, parameters=None, /, **options)</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>This is not defined in PEP 249, but is simply a convenient shortcut to <code>.cursor().execute()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\ndef execute(\n    self,\n    operation: str,\n    parameters: Optional[Any] = None,\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]:\n    \"\"\"Prepare and execute a database operation (query or command).\n\n    This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n    but is simply a convenient shortcut to `.cursor().execute()`.\n\n    Parameters:\n        operation: A database operation (query or command).\n        parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    return self.cursor().execute(operation, parameters, **options)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.execute_map","title":"<code>execute_map(row_type, operation, parameters=None, /, **options)</code>","text":"<pre><code>execute_map(row_type: Type[GenericNewRowType], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[GenericNewRowType, Never, Never]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPandasDataFrame], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, GenericNewPandasDataFrame, Never]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPyArrowTable], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, Never, GenericNewPyArrowTable]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPanderaDataFrameModel], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\n</code></pre> <p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>This is not defined in PEP 249, but is simply a convenient shortcut to <code>.cursor().execute_map()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Union[Type[GenericNewRowType], Type[GenericNewPandasDataFrame], Type[GenericNewPyArrowTable], Type[GenericNewPanderaDataFrameModel]]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cursor</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\ndef execute_map(\n    self,\n    row_type: Union[\n        Type[GenericNewRowType],\n        Type[GenericNewPandasDataFrame],\n        Type[GenericNewPyArrowTable],\n        Type[GenericNewPanderaDataFrameModel],\n    ],\n    operation: str,\n    parameters: \"Optional[Any]\" = None,\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; Cursor:\n    \"\"\"\n    Execute a database operation (query or command) and map each row to a `row_type`.\n\n    This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n    but is simply a convenient shortcut to `.cursor().execute_map()`.\n\n    Parameters:\n        row_type: The type of the row that will be returned.\n        operation: A database operation (query or command).\n        parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    return cast(\n        Cursor,\n        self.cursor().execute_map(\n            row_type,\n            operation,\n            parameters,\n            **options,\n        ),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.executemany","title":"<code>executemany(operation, seq_of_parameters, /, **options)</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>This is not defined in PEP 249, but is simply a convenient shortcut to <code>.cursor().executemany()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\ndef executemany(\n    self,\n    operation: str,\n    seq_of_parameters: Sequence[Any],\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]:\n    \"\"\"Prepare a database operation (query or command)\n    and then execute it against all parameter sequences or mappings.\n\n    This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n    but is simply a convenient shortcut to `.cursor().executemany()`.\n\n    Parameters:\n        operation: A database operation (query or command).\n        seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    return self.cursor().executemany(operation, seq_of_parameters, **options)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters, /, **options)</code>","text":"<pre><code>executemany_map(row_type: Type[GenericNewRowType], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[GenericNewRowType, Never, Never]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPandasDataFrame], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, GenericNewPandasDataFrame, Never]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPyArrowTable], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, Never, GenericNewPyArrowTable]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPanderaDataFrameModel], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\n</code></pre> <p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>This is not defined in PEP 249, but is simply a convenient shortcut to <code>.cursor().executemany_map()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Union[Type[GenericNewRowType], Type[GenericNewPandasDataFrame], Type[GenericNewPyArrowTable], Type[GenericNewPanderaDataFrameModel]]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cursor</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\ndef executemany_map(\n    self,\n    row_type: Union[\n        Type[GenericNewRowType],\n        Type[GenericNewPandasDataFrame],\n        Type[GenericNewPyArrowTable],\n        Type[GenericNewPanderaDataFrameModel],\n    ],\n    operation: str,\n    seq_of_parameters: Sequence[Any],\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; Cursor:\n    \"\"\"Execute a database operation (query or command) against all parameter sequences or mappings.\n\n    This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n    but is simply a convenient shortcut to `.cursor().executemany_map()`.\n\n    Parameters:\n        row_type: The type of the row that will be returned.\n        operation: A database operation (query or command).\n        seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    return cast(\n        Cursor,\n        self.cursor().executemany_map(\n            row_type, operation, seq_of_parameters, **options\n        ),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Connection.rollback","title":"<code>rollback()</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-snowflake/src/turu/snowflake/connection.py</code> <pre><code>@override\ndef rollback(self) -&gt; None:\n    self._raw_connection.rollback()\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor","title":"<code>turu.snowflake.Cursor</code>","text":"<p>A cursor is a database object that is used to manage the context of a fetch operation.</p> <p>This class is a wrapper around the <code>snowflake.connector.cursor.SnowflakeCursor</code> class.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>class Cursor(\n    Generic[GenericRowType, GenericPandasDataFrame, GenericPyArrowTable],\n    turu.core.cursor.Cursor[GenericRowType, Any],\n):\n    \"\"\"\n    A cursor is a database object that is used to manage the context of a fetch operation.\n\n    This class is a wrapper around the `snowflake.connector.cursor.SnowflakeCursor` class.\n    \"\"\"\n\n    def __init__(\n        self,\n        cursor: snowflake.connector.cursor.SnowflakeCursor,\n        *,\n        row_type: Optional[Type[GenericRowType]] = None,\n    ) -&gt; None:\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[GenericRowType]] = row_type\n\n    @property\n    def rowcount(self) -&gt; int:\n        return self._raw_cursor.rowcount or -1\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize\n\n    @arraysize.setter\n    def arraysize(self, size: int) -&gt; None:\n        self._raw_cursor.arraysize = size\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_cursor.close()\n\n    @override\n    def execute(\n        self,\n        operation: str,\n        parameters: Optional[Any] = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]\":\n        \"\"\"Prepare and execute a database operation (query or command).\n\n        Parameters:\n            operation: A database operation (query or command).\n            parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        self._raw_cursor.execute(operation, parameters, **options)\n        self._row_type = None\n\n        return cast(Cursor, self)\n\n    @override\n    def executemany(\n        self,\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]\":\n        \"\"\"Prepare a database operation (query or command)\n        and then execute it against all parameter sequences or mappings.\n\n        Parameters:\n            operation: A database operation (query or command).\n            seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        self._raw_cursor.executemany(operation, seq_of_parameters, **options)\n        self._row_type = None\n\n        return cast(Cursor, self)\n\n    @overload\n    def execute_map(\n        self,\n        row_type: Type[GenericNewRowType],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[GenericNewRowType, Never, Never]\": ...\n\n    @overload\n    def execute_map(\n        self,\n        row_type: Type[GenericNewPandasDataFrame],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[Never, GenericNewPandasDataFrame, Never]\": ...\n\n    @overload\n    def execute_map(\n        self,\n        row_type: Type[GenericNewPyArrowTable],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[Never,  Never, GenericNewPyArrowTable]\": ...\n\n    @overload\n    def execute_map(\n        self,\n        row_type: Type[GenericNewPanderaDataFrameModel],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\": ...\n\n    @override\n    def execute_map(\n        self,\n        row_type: Union[\n            Type[GenericNewRowType],\n            Type[GenericNewPandasDataFrame],\n            Type[GenericNewPyArrowTable],\n            Type[GenericNewPanderaDataFrameModel],\n        ],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor\":\n        \"\"\"\n        Execute a database operation (query or command) and map each row to a `row_type`.\n\n        Parameters:\n            row_type: The type of the row that will be returned.\n            operation: A database operation (query or command).\n            parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        self._raw_cursor.execute(operation, parameters, **options)\n        self._row_type = cast(Type[GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @overload\n    def executemany_map(\n        self,\n        row_type: Type[GenericNewRowType],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[GenericNewRowType, Never, Never]\":\n        pass\n\n    @overload\n    def executemany_map(\n        self,\n        row_type: Type[GenericNewPandasDataFrame],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[Never, GenericNewPandasDataFrame, Never]\":\n        pass\n\n    @overload\n    def executemany_map(\n        self,\n        row_type: Type[GenericNewPyArrowTable],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[Never, Never, GenericNewPyArrowTable]\":\n        pass\n\n    @overload\n    def executemany_map(\n        self,\n        row_type: Type[GenericNewPanderaDataFrameModel],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\": ...\n\n    @override\n    def executemany_map(\n        self,\n        row_type: Union[\n            Type[GenericNewRowType],\n            Type[GenericNewPandasDataFrame],\n            Type[GenericNewPyArrowTable],\n            Type[GenericNewPanderaDataFrameModel],\n        ],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"Cursor\":\n        \"\"\"Execute a database operation (query or command) against all parameter sequences or mappings.\n\n        Parameters:\n            row_type: The type of the row that will be returned.\n            operation: A database operation (query or command).\n            seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        self._raw_cursor.executemany(operation, seq_of_parameters, **options)\n        self._row_type = cast(Type[GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @override\n    def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n    ) -&gt; \"Cursor[Never, Never, Never]\":\n        return cast(Cursor, self.execute(operation, parameters))\n\n    @override\n    def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n    ) -&gt; \"Cursor[Never, Never, Never]\":\n        return cast(Cursor, self.executemany(operation, seq_of_parameters))\n\n    @override\n    def fetchone(self) -&gt; Optional[GenericRowType]:\n        row = self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        elif self._row_type is not None:\n            return turu.core.cursor.map_row(self._row_type, row)\n\n        else:\n            return row  # type: ignore[return-value]\n\n    @override\n    def fetchmany(self, size: Optional[int] = None) -&gt; List[GenericRowType]:\n        return [\n            turu.core.cursor.map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchmany(\n                size if size is not None else self.arraysize\n            )\n        ]\n\n    @override\n    def fetchall(self) -&gt; List[GenericRowType]:\n        return [\n            turu.core.cursor.map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchall()\n        ]\n\n    @override\n    def __next__(self) -&gt; GenericRowType:\n        next_row = self._raw_cursor.fetchone()\n\n        if next_row is None:\n            raise StopIteration()\n\n        if self._row_type is not None:\n            return turu.core.cursor.map_row(self._row_type, next_row)\n\n        else:\n            return next_row  # type: ignore[return-value]\n\n    def fetch_arrow_all(self) -&gt; GenericPyArrowTable:\n        \"\"\"Fetches a single Arrow Table.\"\"\"\n\n        return cast(\n            GenericPyArrowTable,\n            self._raw_cursor.fetch_arrow_all(force_return_table=True),\n        )\n\n    def fetch_arrow_batches(self) -&gt; \"Iterator[GenericPyArrowTable]\":\n        \"\"\"Fetches Arrow Tables in batches, where 'batch' refers to Snowflake Chunk.\"\"\"\n\n        return cast(\n            Iterator[GenericPyArrowTable], self._raw_cursor.fetch_arrow_batches()\n        )\n\n    def fetch_pandas_all(self, **kwargs: Any) -&gt; \"GenericPandasDataFrame\":\n        \"\"\"Fetch a single Pandas dataframe.\"\"\"\n        df = self._raw_cursor.fetch_pandas_all(**kwargs)\n\n        if self._row_type and issubclass(self._row_type, PanderaDataFrameModel):\n            df = self._row_type.validate(df, inplace=True)  # type: ignore[assignment]\n\n        return cast(GenericPandasDataFrame, df)\n\n    def fetch_pandas_batches(self, **kwargs: Any) -&gt; \"Iterator[GenericPandasDataFrame]\":\n        \"\"\"Fetch Pandas dataframes in batches, where 'batch' refers to Snowflake Chunk.\"\"\"\n\n        return cast(\n            Iterator[GenericPandasDataFrame],\n            self._raw_cursor.fetch_pandas_batches(**kwargs),\n        )\n\n    def use_warehouse(self, warehouse: str, /) -&gt; Self:\n        \"\"\"Use a warehouse in cursor.\"\"\"\n\n        self._raw_cursor.execute(f\"use warehouse {warehouse}\")\n\n        return self\n\n    def use_database(self, database: str, /) -&gt; Self:\n        \"\"\"Use a database in cursor.\"\"\"\n\n        self._raw_cursor.execute(f\"use database {database}\")\n\n        return self\n\n    def use_schema(self, schema: str, /) -&gt; Self:\n        \"\"\"Use a schema in cursor.\"\"\"\n\n        self._raw_cursor.execute(f\"use schema {schema}\")\n\n        return self\n\n    def use_role(self, role: str, /) -&gt; Self:\n        \"\"\"Use a role in cursor.\"\"\"\n\n        self._raw_cursor.execute(f\"use role {role}\")\n\n        return self\n\n    @property\n    def _RecordCursor(self):\n        import turu.snowflake.record.record_cursor\n\n        return turu.snowflake.record.record_cursor.RecordCursor\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>The number of rows to fetch at a time with <code>.fetchmany()</code>.</p> <p>It defaults to 1 meaning to fetch a single row at a time.</p>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>The number of rows that the last <code>.execute*()</code> produced (for DQL statements like ) or affected (for DML statements like or ).</p> <p>The attribute is <code>-1</code> in case no <code>.execute*()</code> has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.execute","title":"<code>execute(operation, parameters=None, /, **options)</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef execute(\n    self,\n    operation: str,\n    parameters: Optional[Any] = None,\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]\":\n    \"\"\"Prepare and execute a database operation (query or command).\n\n    Parameters:\n        operation: A database operation (query or command).\n        parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    self._raw_cursor.execute(operation, parameters, **options)\n    self._row_type = None\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None, /, **options)</code>","text":"<pre><code>execute_map(row_type: Type[GenericNewRowType], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[GenericNewRowType, Never, Never]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPandasDataFrame], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, GenericNewPandasDataFrame, Never]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPyArrowTable], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, Never, GenericNewPyArrowTable]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPanderaDataFrameModel], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\n</code></pre> <p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Union[Type[GenericNewRowType], Type[GenericNewPandasDataFrame], Type[GenericNewPyArrowTable], Type[GenericNewPanderaDataFrameModel]]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cursor</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef execute_map(\n    self,\n    row_type: Union[\n        Type[GenericNewRowType],\n        Type[GenericNewPandasDataFrame],\n        Type[GenericNewPyArrowTable],\n        Type[GenericNewPanderaDataFrameModel],\n    ],\n    operation: str,\n    parameters: \"Optional[Any]\" = None,\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"Cursor\":\n    \"\"\"\n    Execute a database operation (query or command) and map each row to a `row_type`.\n\n    Parameters:\n        row_type: The type of the row that will be returned.\n        operation: A database operation (query or command).\n        parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    self._raw_cursor.execute(operation, parameters, **options)\n    self._row_type = cast(Type[GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: \"Optional[Any]\" = None,\n) -&gt; \"Cursor[Never, Never, Never]\":\n    return cast(Cursor, self.execute(operation, parameters))\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.executemany","title":"<code>executemany(operation, seq_of_parameters, /, **options)</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef executemany(\n    self,\n    operation: str,\n    seq_of_parameters: Sequence[Any],\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"Cursor[Tuple[Any], PandasDataFrame, PyArrowTable]\":\n    \"\"\"Prepare a database operation (query or command)\n    and then execute it against all parameter sequences or mappings.\n\n    Parameters:\n        operation: A database operation (query or command).\n        seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    self._raw_cursor.executemany(operation, seq_of_parameters, **options)\n    self._row_type = None\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters, /, **options)</code>","text":"<pre><code>executemany_map(row_type: Type[GenericNewRowType], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[GenericNewRowType, Never, Never]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPandasDataFrame], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, GenericNewPandasDataFrame, Never]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPyArrowTable], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, Never, GenericNewPyArrowTable]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPanderaDataFrameModel], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; Cursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\n</code></pre> <p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Union[Type[GenericNewRowType], Type[GenericNewPandasDataFrame], Type[GenericNewPyArrowTable], Type[GenericNewPanderaDataFrameModel]]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cursor</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef executemany_map(\n    self,\n    row_type: Union[\n        Type[GenericNewRowType],\n        Type[GenericNewPandasDataFrame],\n        Type[GenericNewPyArrowTable],\n        Type[GenericNewPanderaDataFrameModel],\n    ],\n    operation: str,\n    seq_of_parameters: \"Sequence[Any]\",\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"Cursor\":\n    \"\"\"Execute a database operation (query or command) against all parameter sequences or mappings.\n\n    Parameters:\n        row_type: The type of the row that will be returned.\n        operation: A database operation (query or command).\n        seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    self._raw_cursor.executemany(operation, seq_of_parameters, **options)\n    self._row_type = cast(Type[GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: \"Sequence[Any]\",\n) -&gt; \"Cursor[Never, Never, Never]\":\n    return cast(Cursor, self.executemany(operation, seq_of_parameters))\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.fetch_arrow_all","title":"<code>fetch_arrow_all()</code>","text":"<p>Fetches a single Arrow Table.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>def fetch_arrow_all(self) -&gt; GenericPyArrowTable:\n    \"\"\"Fetches a single Arrow Table.\"\"\"\n\n    return cast(\n        GenericPyArrowTable,\n        self._raw_cursor.fetch_arrow_all(force_return_table=True),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.fetch_arrow_batches","title":"<code>fetch_arrow_batches()</code>","text":"<p>Fetches Arrow Tables in batches, where 'batch' refers to Snowflake Chunk.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>def fetch_arrow_batches(self) -&gt; \"Iterator[GenericPyArrowTable]\":\n    \"\"\"Fetches Arrow Tables in batches, where 'batch' refers to Snowflake Chunk.\"\"\"\n\n    return cast(\n        Iterator[GenericPyArrowTable], self._raw_cursor.fetch_arrow_batches()\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.fetch_pandas_all","title":"<code>fetch_pandas_all(**kwargs)</code>","text":"<p>Fetch a single Pandas dataframe.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>def fetch_pandas_all(self, **kwargs: Any) -&gt; \"GenericPandasDataFrame\":\n    \"\"\"Fetch a single Pandas dataframe.\"\"\"\n    df = self._raw_cursor.fetch_pandas_all(**kwargs)\n\n    if self._row_type and issubclass(self._row_type, PanderaDataFrameModel):\n        df = self._row_type.validate(df, inplace=True)  # type: ignore[assignment]\n\n    return cast(GenericPandasDataFrame, df)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.fetch_pandas_batches","title":"<code>fetch_pandas_batches(**kwargs)</code>","text":"<p>Fetch Pandas dataframes in batches, where 'batch' refers to Snowflake Chunk.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>def fetch_pandas_batches(self, **kwargs: Any) -&gt; \"Iterator[GenericPandasDataFrame]\":\n    \"\"\"Fetch Pandas dataframes in batches, where 'batch' refers to Snowflake Chunk.\"\"\"\n\n    return cast(\n        Iterator[GenericPandasDataFrame],\n        self._raw_cursor.fetch_pandas_batches(**kwargs),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.fetchall","title":"<code>fetchall()</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef fetchall(self) -&gt; List[GenericRowType]:\n    return [\n        turu.core.cursor.map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchall()\n    ]\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.fetchmany","title":"<code>fetchmany(size=None)</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef fetchmany(self, size: Optional[int] = None) -&gt; List[GenericRowType]:\n    return [\n        turu.core.cursor.map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchmany(\n            size if size is not None else self.arraysize\n        )\n    ]\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.fetchone","title":"<code>fetchone()</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>@override\ndef fetchone(self) -&gt; Optional[GenericRowType]:\n    row = self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    elif self._row_type is not None:\n        return turu.core.cursor.map_row(self._row_type, row)\n\n    else:\n        return row  # type: ignore[return-value]\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.use_database","title":"<code>use_database(database)</code>","text":"<p>Use a database in cursor.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>def use_database(self, database: str, /) -&gt; Self:\n    \"\"\"Use a database in cursor.\"\"\"\n\n    self._raw_cursor.execute(f\"use database {database}\")\n\n    return self\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.use_role","title":"<code>use_role(role)</code>","text":"<p>Use a role in cursor.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>def use_role(self, role: str, /) -&gt; Self:\n    \"\"\"Use a role in cursor.\"\"\"\n\n    self._raw_cursor.execute(f\"use role {role}\")\n\n    return self\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.use_schema","title":"<code>use_schema(schema)</code>","text":"<p>Use a schema in cursor.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>def use_schema(self, schema: str, /) -&gt; Self:\n    \"\"\"Use a schema in cursor.\"\"\"\n\n    self._raw_cursor.execute(f\"use schema {schema}\")\n\n    return self\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.Cursor.use_warehouse","title":"<code>use_warehouse(warehouse)</code>","text":"<p>Use a warehouse in cursor.</p> Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>def use_warehouse(self, warehouse: str, /) -&gt; Self:\n    \"\"\"Use a warehouse in cursor.\"\"\"\n\n    self._raw_cursor.execute(f\"use warehouse {warehouse}\")\n\n    return self\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection","title":"<code>turu.snowflake.AsyncConnection</code>","text":"Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>class AsyncConnection(turu.core.async_connection.AsyncConnection):\n    def __init__(self, connection: snowflake.connector.SnowflakeConnection):\n        self._raw_connection = connection\n\n    @classmethod\n    @override\n    async def connect(  # type: ignore[override]\n        cls,\n        connection_name: Optional[str] = None,\n        connections_file_path: Optional[Path] = None,\n        user: Optional[str] = None,\n        password: Optional[str] = None,\n        account: Optional[str] = None,\n        database: Optional[str] = None,\n        schema: Optional[str] = None,\n        warehouse: Optional[str] = None,\n        role: Optional[str] = None,\n        private_key: \"Union[str ,bytes ,RSAPrivateKey, None]\" = None,\n        private_key_file: Union[str, Path, None] = None,\n        private_key_passphrase: Union[str, bytes, None] = None,\n        **kwargs,\n    ) -&gt; Self:\n        if isinstance(private_key_file, (str, Path)):\n            with open(private_key_file, \"rb\") as key:\n                private_key = key.read()\n        elif isinstance(private_key, str):\n            private_key = private_key.encode(\"utf-8\")\n\n        if isinstance(private_key, bytes):\n            from turu.snowflake._key_pair import load_private_key\n\n            if isinstance(private_key_passphrase, str):\n                private_key_passphrase = private_key_passphrase.encode(\"utf-8\")\n\n            private_key = load_private_key(private_key, private_key_passphrase)\n\n        return cls(\n            snowflake.connector.SnowflakeConnection(\n                connection_name,\n                connections_file_path,\n                user=user,\n                password=password,\n                account=account,\n                database=database,\n                schema=schema,\n                warehouse=warehouse,\n                role=role,\n                private_key=private_key,\n                **kwargs,\n            )\n        )\n\n    @classmethod\n    @override\n    async def connect_from_env(  # type: ignore[override]\n        cls,\n        connection_name: Optional[str] = None,\n        connections_file_path: Optional[Path] = None,\n        user_envname: str = \"SNOWFLAKE_USER\",\n        password_envname: str = \"SNOWFLAKE_PASSWORD\",\n        account_envname: str = \"SNOWFLAKE_ACCOUNT\",\n        database_envname: str = \"SNOWFLAKE_DATABASE\",\n        schema_envname: str = \"SNOWFLAKE_SCHEMA\",\n        warehouse_envname: str = \"SNOWFLAKE_WAREHOUSE\",\n        role_envname: str = \"SNOWFLAKE_ROLE\",\n        authenticator_envname: str = \"SNOWFLAKE_AUTHENTICATOR\",\n        private_key_envname: str = \"SNOWFLAKE_PRIVATE_KEY\",\n        private_key_file_envname: str = \"SNOWFLAKE_PRIVATE_KEY_FILE\",\n        private_key_passphrase_envname: str = \"SNOWFLAKE_PRIVATE_KEY_PASSPHRASE\",\n        **kwargs,\n    ) -&gt; Self:\n        if (\n            authenticator := os.environ.get(\n                authenticator_envname,\n                kwargs.get(\"authenticator\"),\n            )\n        ) and \"authenticator\" not in kwargs:\n            kwargs[\"authenticator\"] = authenticator\n\n        return await cls.connect(\n            connection_name,\n            connections_file_path,\n            user=kwargs.pop(\"user\", os.environ.get(user_envname)),\n            password=kwargs.pop(\"password\", os.environ.get(password_envname)),\n            account=kwargs.get(\"account\", os.environ.get(account_envname)),\n            database=kwargs.get(\"database\", os.environ.get(database_envname)),\n            schema=kwargs.get(\"schema\", os.environ.get(schema_envname)),\n            warehouse=kwargs.get(\"warehouse\", os.environ.get(warehouse_envname)),\n            role=kwargs.get(\"role\", os.environ.get(role_envname)),\n            private_key=kwargs.pop(\"private_key\", os.environ.get(private_key_envname)),\n            private_key_file=kwargs.pop(\n                \"private_key_file\", os.environ.get(private_key_file_envname)\n            ),\n            private_key_passphrase=kwargs.pop(\n                \"private_key_passphrase\", os.environ.get(private_key_passphrase_envname)\n            ),\n            **kwargs,\n        )\n\n    @override\n    async def close(self) -&gt; None:\n        self._raw_connection.close()\n\n    @override\n    async def commit(self) -&gt; None:\n        self._raw_connection.commit()\n\n    @override\n    async def rollback(self) -&gt; None:\n        self._raw_connection.rollback()\n\n    @override\n    async def cursor(self) -&gt; AsyncCursor[Never, Never, Never]:\n        return AsyncCursor(self._raw_connection.cursor())\n\n    @override\n    async def execute(\n        self,\n        operation: str,\n        parameters: Optional[Any] = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]:\n        \"\"\"Prepare and execute a database operation (query or command).\n\n        This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n        but is simply a convenient shortcut to `.cursor().execute()`.\n\n        Parameters:\n            operation: A database operation (query or command).\n            parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        return await (await self.cursor()).execute(operation, parameters, **options)\n\n    @override\n    async def executemany(\n        self,\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]:\n        \"\"\"Prepare a database operation (query or command)\n        and then execute it against all parameter sequences or mappings.\n\n        This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n        but is simply a convenient shortcut to `.cursor().executemany()`.\n\n        Parameters:\n            operation: A database operation (query or command).\n            seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        return await (await self.cursor()).executemany(\n            operation, seq_of_parameters, **options\n        )\n\n    @overload\n    async def execute_map(\n        self,\n        row_type: Type[GenericNewRowType],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[GenericNewRowType, Never, Never]\": ...\n\n    @overload\n    async def execute_map(\n        self,\n        row_type: Type[GenericNewPandasDataFrame],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[Never, GenericNewPandasDataFrame, Never]\": ...\n\n    @overload\n    async def execute_map(\n        self,\n        row_type: Type[GenericNewPyArrowTable],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[Never, Never, GenericNewPyArrowTable]\": ...\n\n    @overload\n    async def execute_map(\n        self,\n        row_type: Type[GenericNewPanderaDataFrameModel],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; (\n        \"AsyncCursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\"\n    ): ...\n\n    @override\n    async def execute_map(\n        self,\n        row_type: Union[\n            Type[GenericNewRowType],\n            Type[GenericNewPandasDataFrame],\n            Type[GenericNewPyArrowTable],\n            Type[GenericNewPanderaDataFrameModel],\n        ],\n        operation: str,\n        parameters: Optional[Any] = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor\":\n        \"\"\"\n        Execute a database operation (query or command) and map each row to a `row_type`.\n\n        This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n        but is simply a convenient shortcut to `.cursor().execute_map()`.\n\n        Parameters:\n            row_type: The type of the row that will be returned.\n            operation: A database operation (query or command).\n            parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        return cast(\n            AsyncCursor,\n            await (await self.cursor()).execute_map(\n                row_type,\n                operation,\n                parameters,\n                **options,\n            ),\n        )\n\n    @overload\n    async def executemany_map(\n        self,\n        row_type: Type[GenericNewRowType],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; AsyncCursor[GenericNewRowType, Never, Never]: ...\n\n    @overload\n    async def executemany_map(\n        self,\n        row_type: Type[GenericNewPandasDataFrame],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; AsyncCursor[Never, GenericNewPandasDataFrame, Never]: ...\n\n    @overload\n    async def executemany_map(\n        self,\n        row_type: Type[GenericNewPyArrowTable],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; AsyncCursor[Never, Never, GenericNewPyArrowTable]: ...\n\n    @overload\n    async def executemany_map(\n        self,\n        row_type: Type[GenericNewPanderaDataFrameModel],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; (\n        \"AsyncCursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\"\n    ): ...\n\n    @override\n    async def executemany_map(\n        self,\n        row_type: Union[\n            Type[GenericNewRowType],\n            Type[GenericNewPandasDataFrame],\n            Type[GenericNewPyArrowTable],\n            Type[GenericNewPanderaDataFrameModel],\n        ],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor\":\n        \"\"\"Execute a database operation (query or command) against all parameter sequences or mappings.\n\n        This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n        but is simply a convenient shortcut to `.cursor().executemany_map()`.\n\n        Parameters:\n            operation: A database operation (query or command).\n            seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        return cast(\n            AsyncCursor,\n            await (await self.cursor()).executemany_map(\n                row_type,\n                operation,\n                seq_of_parameters,\n                **options,\n            ),\n        )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the connection now.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@override\nasync def close(self) -&gt; None:\n    self._raw_connection.close()\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.commit","title":"<code>commit()</code>  <code>async</code>","text":"<p>Commit any pending transaction to the database.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@override\nasync def commit(self) -&gt; None:\n    self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.connect","title":"<code>connect(connection_name=None, connections_file_path=None, user=None, password=None, account=None, database=None, schema=None, warehouse=None, role=None, private_key=None, private_key_file=None, private_key_passphrase=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@classmethod\n@override\nasync def connect(  # type: ignore[override]\n    cls,\n    connection_name: Optional[str] = None,\n    connections_file_path: Optional[Path] = None,\n    user: Optional[str] = None,\n    password: Optional[str] = None,\n    account: Optional[str] = None,\n    database: Optional[str] = None,\n    schema: Optional[str] = None,\n    warehouse: Optional[str] = None,\n    role: Optional[str] = None,\n    private_key: \"Union[str ,bytes ,RSAPrivateKey, None]\" = None,\n    private_key_file: Union[str, Path, None] = None,\n    private_key_passphrase: Union[str, bytes, None] = None,\n    **kwargs,\n) -&gt; Self:\n    if isinstance(private_key_file, (str, Path)):\n        with open(private_key_file, \"rb\") as key:\n            private_key = key.read()\n    elif isinstance(private_key, str):\n        private_key = private_key.encode(\"utf-8\")\n\n    if isinstance(private_key, bytes):\n        from turu.snowflake._key_pair import load_private_key\n\n        if isinstance(private_key_passphrase, str):\n            private_key_passphrase = private_key_passphrase.encode(\"utf-8\")\n\n        private_key = load_private_key(private_key, private_key_passphrase)\n\n    return cls(\n        snowflake.connector.SnowflakeConnection(\n            connection_name,\n            connections_file_path,\n            user=user,\n            password=password,\n            account=account,\n            database=database,\n            schema=schema,\n            warehouse=warehouse,\n            role=role,\n            private_key=private_key,\n            **kwargs,\n        )\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.connect_from_env","title":"<code>connect_from_env(connection_name=None, connections_file_path=None, user_envname='SNOWFLAKE_USER', password_envname='SNOWFLAKE_PASSWORD', account_envname='SNOWFLAKE_ACCOUNT', database_envname='SNOWFLAKE_DATABASE', schema_envname='SNOWFLAKE_SCHEMA', warehouse_envname='SNOWFLAKE_WAREHOUSE', role_envname='SNOWFLAKE_ROLE', authenticator_envname='SNOWFLAKE_AUTHENTICATOR', private_key_envname='SNOWFLAKE_PRIVATE_KEY', private_key_file_envname='SNOWFLAKE_PRIVATE_KEY_FILE', private_key_passphrase_envname='SNOWFLAKE_PRIVATE_KEY_PASSPHRASE', **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@classmethod\n@override\nasync def connect_from_env(  # type: ignore[override]\n    cls,\n    connection_name: Optional[str] = None,\n    connections_file_path: Optional[Path] = None,\n    user_envname: str = \"SNOWFLAKE_USER\",\n    password_envname: str = \"SNOWFLAKE_PASSWORD\",\n    account_envname: str = \"SNOWFLAKE_ACCOUNT\",\n    database_envname: str = \"SNOWFLAKE_DATABASE\",\n    schema_envname: str = \"SNOWFLAKE_SCHEMA\",\n    warehouse_envname: str = \"SNOWFLAKE_WAREHOUSE\",\n    role_envname: str = \"SNOWFLAKE_ROLE\",\n    authenticator_envname: str = \"SNOWFLAKE_AUTHENTICATOR\",\n    private_key_envname: str = \"SNOWFLAKE_PRIVATE_KEY\",\n    private_key_file_envname: str = \"SNOWFLAKE_PRIVATE_KEY_FILE\",\n    private_key_passphrase_envname: str = \"SNOWFLAKE_PRIVATE_KEY_PASSPHRASE\",\n    **kwargs,\n) -&gt; Self:\n    if (\n        authenticator := os.environ.get(\n            authenticator_envname,\n            kwargs.get(\"authenticator\"),\n        )\n    ) and \"authenticator\" not in kwargs:\n        kwargs[\"authenticator\"] = authenticator\n\n    return await cls.connect(\n        connection_name,\n        connections_file_path,\n        user=kwargs.pop(\"user\", os.environ.get(user_envname)),\n        password=kwargs.pop(\"password\", os.environ.get(password_envname)),\n        account=kwargs.get(\"account\", os.environ.get(account_envname)),\n        database=kwargs.get(\"database\", os.environ.get(database_envname)),\n        schema=kwargs.get(\"schema\", os.environ.get(schema_envname)),\n        warehouse=kwargs.get(\"warehouse\", os.environ.get(warehouse_envname)),\n        role=kwargs.get(\"role\", os.environ.get(role_envname)),\n        private_key=kwargs.pop(\"private_key\", os.environ.get(private_key_envname)),\n        private_key_file=kwargs.pop(\n            \"private_key_file\", os.environ.get(private_key_file_envname)\n        ),\n        private_key_passphrase=kwargs.pop(\n            \"private_key_passphrase\", os.environ.get(private_key_passphrase_envname)\n        ),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.cursor","title":"<code>cursor()</code>  <code>async</code>","text":"<p>Return a new Cursor Object using the connection.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@override\nasync def cursor(self) -&gt; AsyncCursor[Never, Never, Never]:\n    return AsyncCursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.execute","title":"<code>execute(operation, parameters=None, /, **options)</code>  <code>async</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>This is not defined in PEP 249, but is simply a convenient shortcut to <code>.cursor().execute()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@override\nasync def execute(\n    self,\n    operation: str,\n    parameters: Optional[Any] = None,\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]:\n    \"\"\"Prepare and execute a database operation (query or command).\n\n    This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n    but is simply a convenient shortcut to `.cursor().execute()`.\n\n    Parameters:\n        operation: A database operation (query or command).\n        parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    return await (await self.cursor()).execute(operation, parameters, **options)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.execute_map","title":"<code>execute_map(row_type, operation, parameters=None, /, **options)</code>  <code>async</code>","text":"<pre><code>execute_map(row_type: Type[GenericNewRowType], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[GenericNewRowType, Never, Never]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPandasDataFrame], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, GenericNewPandasDataFrame, Never]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPyArrowTable], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, Never, GenericNewPyArrowTable]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPanderaDataFrameModel], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\n</code></pre> <p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>This is not defined in PEP 249, but is simply a convenient shortcut to <code>.cursor().execute_map()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Union[Type[GenericNewRowType], Type[GenericNewPandasDataFrame], Type[GenericNewPyArrowTable], Type[GenericNewPanderaDataFrameModel]]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncCursor</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@override\nasync def execute_map(\n    self,\n    row_type: Union[\n        Type[GenericNewRowType],\n        Type[GenericNewPandasDataFrame],\n        Type[GenericNewPyArrowTable],\n        Type[GenericNewPanderaDataFrameModel],\n    ],\n    operation: str,\n    parameters: Optional[Any] = None,\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"AsyncCursor\":\n    \"\"\"\n    Execute a database operation (query or command) and map each row to a `row_type`.\n\n    This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n    but is simply a convenient shortcut to `.cursor().execute_map()`.\n\n    Parameters:\n        row_type: The type of the row that will be returned.\n        operation: A database operation (query or command).\n        parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    return cast(\n        AsyncCursor,\n        await (await self.cursor()).execute_map(\n            row_type,\n            operation,\n            parameters,\n            **options,\n        ),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.executemany","title":"<code>executemany(operation, seq_of_parameters, /, **options)</code>  <code>async</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>This is not defined in PEP 249, but is simply a convenient shortcut to <code>.cursor().executemany()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@override\nasync def executemany(\n    self,\n    operation: str,\n    seq_of_parameters: Sequence[Any],\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]:\n    \"\"\"Prepare a database operation (query or command)\n    and then execute it against all parameter sequences or mappings.\n\n    This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n    but is simply a convenient shortcut to `.cursor().executemany()`.\n\n    Parameters:\n        operation: A database operation (query or command).\n        seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    return await (await self.cursor()).executemany(\n        operation, seq_of_parameters, **options\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters, /, **options)</code>  <code>async</code>","text":"<pre><code>executemany_map(row_type: Type[GenericNewRowType], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[GenericNewRowType, Never, Never]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPandasDataFrame], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, GenericNewPandasDataFrame, Never]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPyArrowTable], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, Never, GenericNewPyArrowTable]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPanderaDataFrameModel], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\n</code></pre> <p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>This is not defined in PEP 249, but is simply a convenient shortcut to <code>.cursor().executemany_map()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncCursor</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@override\nasync def executemany_map(\n    self,\n    row_type: Union[\n        Type[GenericNewRowType],\n        Type[GenericNewPandasDataFrame],\n        Type[GenericNewPyArrowTable],\n        Type[GenericNewPanderaDataFrameModel],\n    ],\n    operation: str,\n    seq_of_parameters: Sequence[Any],\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"AsyncCursor\":\n    \"\"\"Execute a database operation (query or command) against all parameter sequences or mappings.\n\n    This is not defined in [PEP 249](https://peps.python.org/pep-0249/),\n    but is simply a convenient shortcut to `.cursor().executemany_map()`.\n\n    Parameters:\n        operation: A database operation (query or command).\n        seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    return cast(\n        AsyncCursor,\n        await (await self.cursor()).executemany_map(\n            row_type,\n            operation,\n            seq_of_parameters,\n            **options,\n        ),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncConnection.rollback","title":"<code>rollback()</code>  <code>async</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_connection.py</code> <pre><code>@override\nasync def rollback(self) -&gt; None:\n    self._raw_connection.rollback()\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor","title":"<code>turu.snowflake.AsyncCursor</code>","text":"Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>class AsyncCursor(\n    Generic[GenericRowType, GenericPandasDataFrame, GenericPyArrowTable],\n    turu.core.async_cursor.AsyncCursor[GenericRowType, Any],\n):\n    def __init__(\n        self,\n        cursor: snowflake.connector.cursor.SnowflakeCursor,\n        *,\n        row_type: Optional[Type[GenericRowType]] = None,\n    ) -&gt; None:\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[GenericRowType]] = row_type\n\n    @property\n    def rowcount(self) -&gt; int:\n        return self._raw_cursor.rowcount or -1\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize\n\n    @arraysize.setter\n    def arraysize(self, size: int) -&gt; None:\n        self._raw_cursor.arraysize = size\n\n    @override\n    async def close(self) -&gt; None:\n        self._raw_cursor.close()\n\n    @override\n    async def execute(\n        self,\n        operation: str,\n        parameters: Optional[Any] = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]\":\n        \"\"\"Prepare and execute a database operation (query or command).\n\n        Parameters:\n            operation: A database operation (query or command).\n            parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        await self._execute_async(operation, parameters, **options)\n        self._row_type = None\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def executemany(\n        self,\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]\":\n        \"\"\"Prepare a database operation (query or command)\n        and then execute it against all parameter sequences or mappings.\n\n        Caution:\n            executemany does not support async. Actually, this is sync.\n\n        Parameters:\n            operation: A database operation (query or command).\n            seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        self._raw_cursor.executemany(operation, seq_of_parameters, **options)\n        self._row_type = None\n\n        return cast(AsyncCursor, self)\n\n    @overload\n    async def execute_map(\n        self,\n        row_type: Type[GenericNewRowType],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[GenericNewRowType, Never, Never]\": ...\n\n    @overload\n    async def execute_map(\n        self,\n        row_type: Type[GenericNewPandasDataFrame],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[Never, GenericNewPandasDataFrame, Never]\": ...\n\n    @overload\n    async def execute_map(\n        self,\n        row_type: Type[GenericNewPyArrowTable],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[Never, Never, GenericNewPyArrowTable]\": ...\n\n    @overload\n    async def execute_map(\n        self,\n        row_type: Type[GenericNewPanderaDataFrameModel],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; (\n        \"AsyncCursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\"\n    ): ...\n\n    @override\n    async def execute_map(\n        self,\n        row_type: Union[\n            Type[GenericNewRowType],\n            Type[GenericNewPandasDataFrame],\n            Type[GenericNewPyArrowTable],\n            Type[GenericNewPanderaDataFrameModel],\n        ],\n        operation: str,\n        parameters: \"Optional[Any]\" = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor\":\n        \"\"\"\n        Execute a database operation (query or command) and map each row to a `row_type`.\n\n        Parameters:\n            row_type: The type of the row that will be returned.\n            operation: A database operation (query or command).\n            parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        self._raw_cursor.execute(operation, parameters, **options)\n        self._row_type = cast(Type[GenericRowType], row_type)\n\n        return cast(AsyncCursor, self)\n\n    @overload\n    async def executemany_map(\n        self,\n        row_type: Type[GenericNewRowType],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[GenericNewRowType, Never, Never]\": ...\n\n    @overload\n    async def executemany_map(\n        self,\n        row_type: Type[GenericNewPandasDataFrame],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[Never, GenericNewPandasDataFrame, Never]\": ...\n\n    @overload\n    async def executemany_map(\n        self,\n        row_type: Type[GenericNewPyArrowTable],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor[Never, Never, GenericNewPyArrowTable]\": ...\n\n    @overload\n    async def executemany_map(\n        self,\n        row_type: Type[GenericNewPanderaDataFrameModel],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; (\n        \"AsyncCursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\"\n    ): ...\n\n    @override\n    async def executemany_map(\n        self,\n        row_type: Union[\n            Type[GenericNewRowType],\n            Type[GenericNewPandasDataFrame],\n            Type[GenericNewPyArrowTable],\n            Type[GenericNewPanderaDataFrameModel],\n        ],\n        operation: str,\n        seq_of_parameters: \"Sequence[Any]\",\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; \"AsyncCursor\":\n        \"\"\"Execute a database operation (query or command) against all parameter sequences or mappings.\n\n        Caution:\n            executemany does not support async. Actually, this is sync.\n\n        Parameters:\n            operation: A database operation (query or command).\n            seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n            options: snowflake connector options\n\n        Returns:\n            A cursor that holds a reference to an operation.\n        \"\"\"\n\n        self._raw_cursor.executemany(operation, seq_of_parameters, **options)\n        self._row_type = cast(Type[GenericRowType], row_type)\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: Optional[Any] = None,\n    ) -&gt; \"AsyncCursor[Never, Never, Never]\":\n        return cast(\n            AsyncCursor,\n            await self.execute(operation, parameters),\n        )\n\n    @override\n    async def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: Sequence[Any],\n    ) -&gt; \"AsyncCursor[Never, Never, Never]\":\n        return cast(\n            AsyncCursor,\n            await self.executemany(operation, seq_of_parameters),\n        )\n\n    @override\n    async def fetchone(self) -&gt; Optional[GenericRowType]:\n        row = self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        elif self._row_type is not None:\n            return map_row(self._row_type, row)\n\n        else:\n            return row  # type: ignore[return-value]\n\n    @override\n    async def fetchmany(self, size: Optional[int] = None) -&gt; List[GenericRowType]:\n        return [\n            map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchmany(\n                size if size is not None else self.arraysize\n            )\n        ]\n\n    @override\n    async def fetchall(self) -&gt; List[GenericRowType]:\n        return [map_row(self._row_type, row) for row in self._raw_cursor.fetchall()]\n\n    async def fetch_arrow_all(self) -&gt; GenericPyArrowTable:\n        \"\"\"Fetches a single Arrow Table.\"\"\"\n\n        return cast(\n            GenericPyArrowTable,\n            self._raw_cursor.fetch_arrow_all(force_return_table=True),\n        )\n\n    async def fetch_arrow_batches(self) -&gt; AsyncIterator[GenericPyArrowTable]:\n        \"\"\"Fetches Arrow Tables in batches, where 'batch' refers to Snowflake Chunk.\"\"\"\n\n        for batch in self._raw_cursor.fetch_arrow_batches():\n            yield cast(GenericPyArrowTable, batch)\n\n    async def fetch_pandas_all(self, **kwargs: Any) -&gt; GenericPandasDataFrame:\n        \"\"\"Fetch Pandas dataframes.\"\"\"\n\n        df = self._raw_cursor.fetch_pandas_all(**kwargs)\n\n        if self._row_type and issubclass(self._row_type, PanderaDataFrameModel):\n            df = self._row_type.validate(df, inplace=True)  # type: ignore[union-attr]\n\n        return cast(GenericPandasDataFrame, df)\n\n    async def fetch_pandas_batches(\n        self, **kwargs: Any\n    ) -&gt; AsyncIterator[GenericPandasDataFrame]:\n        \"\"\"Fetch Pandas dataframes in batches, where 'batch' refers to Snowflake Chunk.\"\"\"\n\n        for batch in self._raw_cursor.fetch_pandas_batches(**kwargs):\n            yield cast(\n                GenericPandasDataFrame,\n                batch,\n            )\n\n    @override\n    async def __anext__(self) -&gt; GenericRowType:\n        next_row = self._raw_cursor.fetchone()\n\n        if next_row is None:\n            raise StopAsyncIteration()\n\n        if self._row_type is not None:\n            return map_row(self._row_type, next_row)\n\n        else:\n            return next_row  # type: ignore[return-value]\n\n    def use_warehouse(self, warehouse: str, /) -&gt; Self:\n        \"\"\"Use a warehouse in cursor.\"\"\"\n\n        self._raw_cursor.execute(f\"use warehouse {warehouse}\")\n\n        return self\n\n    def use_database(self, database: str, /) -&gt; Self:\n        \"\"\"Use a database in cursor.\"\"\"\n\n        self._raw_cursor.execute(f\"use database {database}\")\n\n        return self\n\n    def use_schema(self, schema: str, /) -&gt; Self:\n        \"\"\"Use a schema in cursor.\"\"\"\n\n        self._raw_cursor.execute(f\"use schema {schema}\")\n\n        return self\n\n    def use_role(self, role: str, /) -&gt; Self:\n        \"\"\"Use a role in cursor.\"\"\"\n\n        self._raw_cursor.execute(f\"use role {role}\")\n\n        return self\n\n    async def _execute_async(\n        self,\n        operation: str,\n        parameters: Optional[Any] = None,\n        /,\n        **options: Unpack[ExecuteOptions],\n    ) -&gt; None:\n        cur = self._raw_cursor\n        cur.execute_async(operation, parameters, **options)\n        conn = cur.connection\n        query_id = cur.sfqid\n\n        if query_id:\n            while conn.is_still_running(conn.get_query_status(query_id)):\n                await asyncio.sleep(0.01)\n\n            cur.get_results_from_sfqid(query_id)\n\n    @property\n    def _AsyncRecordCursor(\n        self,\n    ):\n        import turu.snowflake.record.async_record_cursor\n\n        return turu.snowflake.record.async_record_cursor.AsyncRecordCursor\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>This read/write attribute specifies the number of rows to fetch at a time with <code>.fetchmany()</code>. It defaults to 1 meaning to fetch a single row at a time.</p> <p>Implementations must observe this value with respect to the <code>.fetchmany()</code> method, but are free to interact with the database a single row at a time. It may also be used in the implementation of <code>.executemany()</code>.</p>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>the number of rows that the last .execute*() produced (for DQL statements like ) or affected (for DML statements like or ).</p> <p>The attribute is -1 in case no .execute*() has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.execute","title":"<code>execute(operation, parameters=None, /, **options)</code>  <code>async</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def execute(\n    self,\n    operation: str,\n    parameters: Optional[Any] = None,\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]\":\n    \"\"\"Prepare and execute a database operation (query or command).\n\n    Parameters:\n        operation: A database operation (query or command).\n        parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    await self._execute_async(operation, parameters, **options)\n    self._row_type = None\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None, /, **options)</code>  <code>async</code>","text":"<pre><code>execute_map(row_type: Type[GenericNewRowType], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[GenericNewRowType, Never, Never]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPandasDataFrame], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, GenericNewPandasDataFrame, Never]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPyArrowTable], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, Never, GenericNewPyArrowTable]\n</code></pre><pre><code>execute_map(row_type: Type[GenericNewPanderaDataFrameModel], operation: str, parameters: Optional[Any] = None, /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\n</code></pre> <p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Union[Type[GenericNewRowType], Type[GenericNewPandasDataFrame], Type[GenericNewPyArrowTable], Type[GenericNewPanderaDataFrameModel]]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncCursor</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def execute_map(\n    self,\n    row_type: Union[\n        Type[GenericNewRowType],\n        Type[GenericNewPandasDataFrame],\n        Type[GenericNewPyArrowTable],\n        Type[GenericNewPanderaDataFrameModel],\n    ],\n    operation: str,\n    parameters: \"Optional[Any]\" = None,\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"AsyncCursor\":\n    \"\"\"\n    Execute a database operation (query or command) and map each row to a `row_type`.\n\n    Parameters:\n        row_type: The type of the row that will be returned.\n        operation: A database operation (query or command).\n        parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    self._raw_cursor.execute(operation, parameters, **options)\n    self._row_type = cast(Type[GenericRowType], row_type)\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>  <code>async</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method executes an operation (Insert, Update, Delete) that does not return a value with a tag. This tag is used to verify that the specified operation is executed in order when testing with Mock.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: Optional[Any] = None,\n) -&gt; \"AsyncCursor[Never, Never, Never]\":\n    return cast(\n        AsyncCursor,\n        await self.execute(operation, parameters),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.executemany","title":"<code>executemany(operation, seq_of_parameters, /, **options)</code>  <code>async</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> Caution <p>executemany does not support async. Actually, this is sync.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def executemany(\n    self,\n    operation: str,\n    seq_of_parameters: Sequence[Any],\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"AsyncCursor[Tuple[Any], PandasDataFrame, PyArrowTable]\":\n    \"\"\"Prepare a database operation (query or command)\n    and then execute it against all parameter sequences or mappings.\n\n    Caution:\n        executemany does not support async. Actually, this is sync.\n\n    Parameters:\n        operation: A database operation (query or command).\n        seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    self._raw_cursor.executemany(operation, seq_of_parameters, **options)\n    self._row_type = None\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters, /, **options)</code>  <code>async</code>","text":"<pre><code>executemany_map(row_type: Type[GenericNewRowType], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[GenericNewRowType, Never, Never]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPandasDataFrame], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, GenericNewPandasDataFrame, Never]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPyArrowTable], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, Never, GenericNewPyArrowTable]\n</code></pre><pre><code>executemany_map(row_type: Type[GenericNewPanderaDataFrameModel], operation: str, seq_of_parameters: Sequence[Any], /, **options: Unpack[ExecuteOptions]) -&gt; AsyncCursor[Never, PanderaDataFrame[GenericNewPanderaDataFrameModel], Never]\n</code></pre> <p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> Caution <p>executemany does not support async. Actually, this is sync.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Any]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <code>options</code> <code>Unpack[ExecuteOptions]</code> <p>snowflake connector options</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncCursor</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def executemany_map(\n    self,\n    row_type: Union[\n        Type[GenericNewRowType],\n        Type[GenericNewPandasDataFrame],\n        Type[GenericNewPyArrowTable],\n        Type[GenericNewPanderaDataFrameModel],\n    ],\n    operation: str,\n    seq_of_parameters: \"Sequence[Any]\",\n    /,\n    **options: Unpack[ExecuteOptions],\n) -&gt; \"AsyncCursor\":\n    \"\"\"Execute a database operation (query or command) against all parameter sequences or mappings.\n\n    Caution:\n        executemany does not support async. Actually, this is sync.\n\n    Parameters:\n        operation: A database operation (query or command).\n        seq_of_parameters: Parameters may be provided as sequence or mapping and will be bound to variables in the operation.\n        options: snowflake connector options\n\n    Returns:\n        A cursor that holds a reference to an operation.\n    \"\"\"\n\n    self._raw_cursor.executemany(operation, seq_of_parameters, **options)\n    self._row_type = cast(Type[GenericRowType], row_type)\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method executes an operation (Insert, Update, Delete) that does not return a value with a tag. This tag is used to verify that the specified operation is executed in order when testing with Mock.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: Sequence[Any],\n) -&gt; \"AsyncCursor[Never, Never, Never]\":\n    return cast(\n        AsyncCursor,\n        await self.executemany(operation, seq_of_parameters),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.fetch_arrow_all","title":"<code>fetch_arrow_all()</code>  <code>async</code>","text":"<p>Fetches a single Arrow Table.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>async def fetch_arrow_all(self) -&gt; GenericPyArrowTable:\n    \"\"\"Fetches a single Arrow Table.\"\"\"\n\n    return cast(\n        GenericPyArrowTable,\n        self._raw_cursor.fetch_arrow_all(force_return_table=True),\n    )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.fetch_arrow_batches","title":"<code>fetch_arrow_batches()</code>  <code>async</code>","text":"<p>Fetches Arrow Tables in batches, where 'batch' refers to Snowflake Chunk.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>async def fetch_arrow_batches(self) -&gt; AsyncIterator[GenericPyArrowTable]:\n    \"\"\"Fetches Arrow Tables in batches, where 'batch' refers to Snowflake Chunk.\"\"\"\n\n    for batch in self._raw_cursor.fetch_arrow_batches():\n        yield cast(GenericPyArrowTable, batch)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.fetch_pandas_all","title":"<code>fetch_pandas_all(**kwargs)</code>  <code>async</code>","text":"<p>Fetch Pandas dataframes.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>async def fetch_pandas_all(self, **kwargs: Any) -&gt; GenericPandasDataFrame:\n    \"\"\"Fetch Pandas dataframes.\"\"\"\n\n    df = self._raw_cursor.fetch_pandas_all(**kwargs)\n\n    if self._row_type and issubclass(self._row_type, PanderaDataFrameModel):\n        df = self._row_type.validate(df, inplace=True)  # type: ignore[union-attr]\n\n    return cast(GenericPandasDataFrame, df)\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.fetch_pandas_batches","title":"<code>fetch_pandas_batches(**kwargs)</code>  <code>async</code>","text":"<p>Fetch Pandas dataframes in batches, where 'batch' refers to Snowflake Chunk.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>async def fetch_pandas_batches(\n    self, **kwargs: Any\n) -&gt; AsyncIterator[GenericPandasDataFrame]:\n    \"\"\"Fetch Pandas dataframes in batches, where 'batch' refers to Snowflake Chunk.\"\"\"\n\n    for batch in self._raw_cursor.fetch_pandas_batches(**kwargs):\n        yield cast(\n            GenericPandasDataFrame,\n            batch,\n        )\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.fetchall","title":"<code>fetchall()</code>  <code>async</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def fetchall(self) -&gt; List[GenericRowType]:\n    return [map_row(self._row_type, row) for row in self._raw_cursor.fetchall()]\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.fetchmany","title":"<code>fetchmany(size=None)</code>  <code>async</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def fetchmany(self, size: Optional[int] = None) -&gt; List[GenericRowType]:\n    return [\n        map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchmany(\n            size if size is not None else self.arraysize\n        )\n    ]\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.fetchone","title":"<code>fetchone()</code>  <code>async</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>@override\nasync def fetchone(self) -&gt; Optional[GenericRowType]:\n    row = self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    elif self._row_type is not None:\n        return map_row(self._row_type, row)\n\n    else:\n        return row  # type: ignore[return-value]\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.use_database","title":"<code>use_database(database)</code>","text":"<p>Use a database in cursor.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>def use_database(self, database: str, /) -&gt; Self:\n    \"\"\"Use a database in cursor.\"\"\"\n\n    self._raw_cursor.execute(f\"use database {database}\")\n\n    return self\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.use_role","title":"<code>use_role(role)</code>","text":"<p>Use a role in cursor.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>def use_role(self, role: str, /) -&gt; Self:\n    \"\"\"Use a role in cursor.\"\"\"\n\n    self._raw_cursor.execute(f\"use role {role}\")\n\n    return self\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.use_schema","title":"<code>use_schema(schema)</code>","text":"<p>Use a schema in cursor.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>def use_schema(self, schema: str, /) -&gt; Self:\n    \"\"\"Use a schema in cursor.\"\"\"\n\n    self._raw_cursor.execute(f\"use schema {schema}\")\n\n    return self\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.AsyncCursor.use_warehouse","title":"<code>use_warehouse(warehouse)</code>","text":"<p>Use a warehouse in cursor.</p> Source code in <code>turu-snowflake/src/turu/snowflake/async_cursor.py</code> <pre><code>def use_warehouse(self, warehouse: str, /) -&gt; Self:\n    \"\"\"Use a warehouse in cursor.\"\"\"\n\n    self._raw_cursor.execute(f\"use warehouse {warehouse}\")\n\n    return self\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.cursor.ExecuteOptions","title":"<code>turu.snowflake.cursor.ExecuteOptions</code>","text":"Source code in <code>turu-snowflake/src/turu/snowflake/cursor.py</code> <pre><code>class ExecuteOptions(TypedDict, total=False):\n    timeout: int\n    \"\"\"timeout[sec]\"\"\"\n\n    num_statements: int\n    \"\"\"number of statements\"\"\"\n</code></pre>"},{"location":"api/turu-snowflake/#turu.snowflake.cursor.ExecuteOptions.num_statements","title":"<code>num_statements: int</code>  <code>instance-attribute</code>","text":"<p>number of statements</p>"},{"location":"api/turu-snowflake/#turu.snowflake.cursor.ExecuteOptions.timeout","title":"<code>timeout: int</code>  <code>instance-attribute</code>","text":"<p>timeout[sec]</p>"},{"location":"api/turu-sqlite3/","title":"turu.sqlite3","text":""},{"location":"api/turu-sqlite3/#turu.sqlite3.Connection","title":"<code>turu.sqlite3.Connection</code>","text":"Source code in <code>turu-sqlite3/src/turu/sqlite3/connection.py</code> <pre><code>class Connection(turu.core.connection.Connection):\n    def __init__(self, connection: sqlite3.Connection):\n        self._raw_connection = connection\n\n    @override\n    @classmethod\n    def connect(  # type: ignore[override]\n        cls,\n        database: Union[str, bytes],\n        **kwargs: Unpack[\"_ConnectArgs\"],\n    ) -&gt; Self:\n        return cls(sqlite3.Connection(database, **kwargs))\n\n    @override\n    @classmethod\n    def connect_from_env(cls, *args: Any, **kwargs: Any) -&gt; Self:\n        return cls.connect(*args, **kwargs)\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_connection.close()\n\n    @override\n    def commit(self) -&gt; None:\n        self._raw_connection.commit()\n\n    @override\n    def rollback(self) -&gt; None:\n        self._raw_connection.rollback()\n\n    @override\n    def cursor(self) -&gt; Cursor[Never]:\n        return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Connection.close","title":"<code>close()</code>","text":"<p>Close the connection now.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/connection.py</code> <pre><code>@override\ndef close(self) -&gt; None:\n    self._raw_connection.close()\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Connection.commit","title":"<code>commit()</code>","text":"<p>Commit any pending transaction to the database.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/connection.py</code> <pre><code>@override\ndef commit(self) -&gt; None:\n    self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Connection.connect","title":"<code>connect(database, **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/connection.py</code> <pre><code>@override\n@classmethod\ndef connect(  # type: ignore[override]\n    cls,\n    database: Union[str, bytes],\n    **kwargs: Unpack[\"_ConnectArgs\"],\n) -&gt; Self:\n    return cls(sqlite3.Connection(database, **kwargs))\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Connection.connect_from_env","title":"<code>connect_from_env(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/connection.py</code> <pre><code>@override\n@classmethod\ndef connect_from_env(cls, *args: Any, **kwargs: Any) -&gt; Self:\n    return cls.connect(*args, **kwargs)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Connection.cursor","title":"<code>cursor()</code>","text":"<p>Return a new Cursor Object using the connection.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/connection.py</code> <pre><code>@override\ndef cursor(self) -&gt; Cursor[Never]:\n    return Cursor(self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Connection.rollback","title":"<code>rollback()</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/connection.py</code> <pre><code>@override\ndef rollback(self) -&gt; None:\n    self._raw_connection.rollback()\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor","title":"<code>turu.sqlite3.Cursor</code>","text":"Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>class Cursor(\n    turu.core.cursor.Cursor[turu.core.cursor.GenericRowType, \"_Parameters\"],\n):\n    def __init__(\n        self,\n        cursor: sqlite3.Cursor,\n        *,\n        row_type: Optional[Type[turu.core.cursor.GenericRowType]] = None,\n    ):\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[turu.core.cursor.GenericRowType]] = row_type\n\n    @property\n    def rowcount(self) -&gt; int:\n        return self._raw_cursor.rowcount\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize\n\n    @arraysize.setter\n    def arraysize(self, size: int) -&gt; None:\n        self._raw_cursor.arraysize = size\n\n    @override\n    def close(self) -&gt; None:\n        self._raw_cursor.close()\n\n    @override\n    def execute(\n        self, operation: str, parameters: Optional[\"_Parameters\"] = None, /\n    ) -&gt; \"Cursor[Tuple[Any]]\":\n        self._raw_cursor.execute(operation, parameters or ())\n        self._row_type = None\n\n        return cast(Cursor, self)\n\n    @override\n    def executemany(\n        self, operation: str, seq_of_parameters: \"Sequence[_Parameters]\", /\n    ) -&gt; \"Cursor[Tuple[Any]]\":\n        self._raw_cursor.executemany(operation, seq_of_parameters)\n        self._row_type = None\n\n        return cast(Cursor, self)\n\n    @override\n    def execute_map(\n        self,\n        row_type: Type[turu.core.cursor.GenericNewRowType],\n        operation: str,\n        parameters: \"Optional[_Parameters]\" = None,\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n        self._raw_cursor.execute(operation, parameters or ())\n        self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @override\n    def executemany_map(\n        self,\n        row_type: Type[turu.core.cursor.GenericNewRowType],\n        operation: str,\n        seq_of_parameters: \"Sequence[_Parameters]\",\n        /,\n    ) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n        self._raw_cursor.executemany(operation, seq_of_parameters)\n        self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n        return cast(Cursor, self)\n\n    @override\n    def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: \"Optional[_Parameters]\" = None,\n    ) -&gt; \"Cursor[Never]\":\n        return cast(Cursor, self.execute(operation, parameters))\n\n    @override\n    def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: \"Sequence[_Parameters]\",\n    ) -&gt; \"Cursor[Never]\":\n        return cast(Cursor, self.executemany(operation, seq_of_parameters))\n\n    @override\n    def fetchone(self) -&gt; Optional[turu.core.cursor.GenericRowType]:\n        row = self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        elif self._row_type is not None:\n            return turu.core.cursor.map_row(self._row_type, row)\n\n        else:\n            return row\n\n    @override\n    def fetchmany(\n        self, size: Optional[int] = None\n    ) -&gt; List[turu.core.cursor.GenericRowType]:\n        return [\n            turu.core.cursor.map_row(self._row_type, row)\n            for row in (\n                self._raw_cursor.fetchmany(size if size is not None else self.arraysize)\n            )\n        ]\n\n    @override\n    def fetchall(self) -&gt; List[turu.core.cursor.GenericRowType]:\n        return [\n            turu.core.cursor.map_row(self._row_type, row)\n            for row in self._raw_cursor.fetchall()\n        ]\n\n    @override\n    def __next__(self) -&gt; turu.core.cursor.GenericRowType:\n        next_row = next(self._raw_cursor)\n        if self._row_type is not None and next_row is not None:\n            return turu.core.cursor.map_row(self._row_type, next_row)\n\n        else:\n            return next_row\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>The number of rows to fetch at a time with <code>.fetchmany()</code>.</p> <p>It defaults to 1 meaning to fetch a single row at a time.</p>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>The number of rows that the last <code>.execute*()</code> produced (for DQL statements like ) or affected (for DML statements like or ).</p> <p>The attribute is <code>-1</code> in case no <code>.execute*()</code> has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.execute","title":"<code>execute(operation, parameters=None)</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef execute(\n    self, operation: str, parameters: Optional[\"_Parameters\"] = None, /\n) -&gt; \"Cursor[Tuple[Any]]\":\n    self._raw_cursor.execute(operation, parameters or ())\n    self._row_type = None\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None)</code>","text":"<p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Cursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef execute_map(\n    self,\n    row_type: Type[turu.core.cursor.GenericNewRowType],\n    operation: str,\n    parameters: \"Optional[_Parameters]\" = None,\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n    self._raw_cursor.execute(operation, parameters or ())\n    self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: \"Optional[_Parameters]\" = None,\n) -&gt; \"Cursor[Never]\":\n    return cast(Cursor, self.execute(operation, parameters))\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.executemany","title":"<code>executemany(operation, seq_of_parameters)</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef executemany(\n    self, operation: str, seq_of_parameters: \"Sequence[_Parameters]\", /\n) -&gt; \"Cursor[Tuple[Any]]\":\n    self._raw_cursor.executemany(operation, seq_of_parameters)\n    self._row_type = None\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Cursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef executemany_map(\n    self,\n    row_type: Type[turu.core.cursor.GenericNewRowType],\n    operation: str,\n    seq_of_parameters: \"Sequence[_Parameters]\",\n    /,\n) -&gt; \"Cursor[turu.core.cursor.GenericNewRowType]\":\n    self._raw_cursor.executemany(operation, seq_of_parameters)\n    self._row_type = cast(Type[turu.core.cursor.GenericRowType], row_type)\n\n    return cast(Cursor, self)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method is provided for testing, and is intended to be used in conjunction with <code>MockConnection.inject_operation_with_tag</code>.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: \"Sequence[_Parameters]\",\n) -&gt; \"Cursor[Never]\":\n    return cast(Cursor, self.executemany(operation, seq_of_parameters))\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.fetchall","title":"<code>fetchall()</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef fetchall(self) -&gt; List[turu.core.cursor.GenericRowType]:\n    return [\n        turu.core.cursor.map_row(self._row_type, row)\n        for row in self._raw_cursor.fetchall()\n    ]\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.fetchmany","title":"<code>fetchmany(size=None)</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef fetchmany(\n    self, size: Optional[int] = None\n) -&gt; List[turu.core.cursor.GenericRowType]:\n    return [\n        turu.core.cursor.map_row(self._row_type, row)\n        for row in (\n            self._raw_cursor.fetchmany(size if size is not None else self.arraysize)\n        )\n    ]\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.Cursor.fetchone","title":"<code>fetchone()</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/cursor.py</code> <pre><code>@override\ndef fetchone(self) -&gt; Optional[turu.core.cursor.GenericRowType]:\n    row = self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    elif self._row_type is not None:\n        return turu.core.cursor.map_row(self._row_type, row)\n\n    else:\n        return row\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncConnection","title":"<code>turu.sqlite3.AsyncConnection</code>","text":"Source code in <code>turu-sqlite3/src/turu/sqlite3/async_connection.py</code> <pre><code>class AsyncConnection(turu.core.async_connection.AsyncConnection):\n    def __init__(self, connection: aiosqlite.Connection):\n        self._raw_connection = connection\n\n    @override\n    @classmethod\n    async def connect(  # type: ignore[override]\n        cls,\n        database: Union[str, Path],\n        *,\n        iter_chunk_size: int = 64,\n        **kwargs: Unpack[_ConnectArgs],\n    ) -&gt; Self:\n        return cls(\n            await aiosqlite.connect(\n                database,\n                iter_chunk_size=iter_chunk_size,\n                loop=None,\n                **kwargs,\n            )\n        )\n\n    @override\n    @classmethod\n    async def connect_from_env(cls, *args: Any, **kwargs: Any) -&gt; Self:\n        return await cls.connect(*args, **kwargs)\n\n    @override\n    async def close(self) -&gt; None:\n        await self._raw_connection.close()\n\n    @override\n    async def commit(self) -&gt; None:\n        await self._raw_connection.commit()\n\n    @override\n    async def rollback(self) -&gt; None:\n        await self._raw_connection.rollback()\n\n    @override\n    async def cursor(self) -&gt; AsyncCursor[Never]:\n        return AsyncCursor(await self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncConnection.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the connection now.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_connection.py</code> <pre><code>@override\nasync def close(self) -&gt; None:\n    await self._raw_connection.close()\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncConnection.commit","title":"<code>commit()</code>  <code>async</code>","text":"<p>Commit any pending transaction to the database.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_connection.py</code> <pre><code>@override\nasync def commit(self) -&gt; None:\n    await self._raw_connection.commit()\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncConnection.connect","title":"<code>connect(database, *, iter_chunk_size=64, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Connect to a database.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_connection.py</code> <pre><code>@override\n@classmethod\nasync def connect(  # type: ignore[override]\n    cls,\n    database: Union[str, Path],\n    *,\n    iter_chunk_size: int = 64,\n    **kwargs: Unpack[_ConnectArgs],\n) -&gt; Self:\n    return cls(\n        await aiosqlite.connect(\n            database,\n            iter_chunk_size=iter_chunk_size,\n            loop=None,\n            **kwargs,\n        )\n    )\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncConnection.connect_from_env","title":"<code>connect_from_env(*args, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Connect to a database using environment variables.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_connection.py</code> <pre><code>@override\n@classmethod\nasync def connect_from_env(cls, *args: Any, **kwargs: Any) -&gt; Self:\n    return await cls.connect(*args, **kwargs)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncConnection.cursor","title":"<code>cursor()</code>  <code>async</code>","text":"<p>Return a new Cursor Object using the connection.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_connection.py</code> <pre><code>@override\nasync def cursor(self) -&gt; AsyncCursor[Never]:\n    return AsyncCursor(await self._raw_connection.cursor())\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncConnection.rollback","title":"<code>rollback()</code>  <code>async</code>","text":"<p>Roll back to the start of any pending transaction.</p> <p>Closing a connection without committing the changes first will cause an implicit rollback to be performed.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_connection.py</code> <pre><code>@override\nasync def rollback(self) -&gt; None:\n    await self._raw_connection.rollback()\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor","title":"<code>turu.sqlite3.AsyncCursor</code>","text":"Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>class AsyncCursor(\n    turu.core.async_cursor.AsyncCursor[\n        turu.core.async_cursor.GenericRowType, Iterator[Any]\n    ],\n):\n    def __init__(\n        self,\n        cursor: aiosqlite.Cursor,\n        *,\n        row_type: Optional[Type[turu.core.async_cursor.GenericRowType]] = None,\n    ):\n        self._raw_cursor = cursor\n        self._row_type: Optional[Type[turu.core.async_cursor.GenericRowType]] = row_type\n        self._aiter = None\n\n    @property\n    def rowcount(self) -&gt; int:\n        return self._raw_cursor.rowcount\n\n    @property\n    def arraysize(self) -&gt; int:\n        return self._raw_cursor.arraysize\n\n    @arraysize.setter\n    def arraysize(self, size: int) -&gt; None:\n        self._raw_cursor.arraysize = size\n\n    @override\n    async def close(self) -&gt; None:\n        await self._raw_cursor.close()\n\n    @override\n    async def execute(\n        self, operation: str, parameters: Optional[\"Iterator[Any]\"] = None, /\n    ) -&gt; \"AsyncCursor[Tuple[Any]]\":\n        await self._raw_cursor.execute(operation, parameters)\n        self._row_type = None\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def executemany(\n        self, operation: str, seq_of_parameters: \"Sequence[Iterator[Any]]\", /\n    ) -&gt; \"AsyncCursor[Tuple[Any]]\":\n        await self._raw_cursor.executemany(operation, seq_of_parameters)\n        self._row_type = None\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def execute_map(\n        self,\n        row_type: Type[turu.core.async_cursor.GenericNewRowType],\n        operation: str,\n        parameters: \"Optional[Iterator[Any]]\" = None,\n        /,\n    ) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n        await self._raw_cursor.execute(operation, parameters)\n        self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def executemany_map(\n        self,\n        row_type: Type[turu.core.async_cursor.GenericNewRowType],\n        operation: str,\n        seq_of_parameters: \"Sequence[Iterator[Any]]\",\n        /,\n    ) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n        await self._raw_cursor.executemany(operation, seq_of_parameters)\n        self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n        return cast(AsyncCursor, self)\n\n    @override\n    async def execute_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        parameters: \"Optional[Iterator[Any]]\" = None,\n    ) -&gt; turu.core.async_cursor.AsyncCursor[Never, Iterator[Any]]:\n        return cast(\n            turu.core.async_cursor.AsyncCursor,\n            await self.execute(operation, parameters),\n        )\n\n    @override\n    async def executemany_with_tag(\n        self,\n        tag: Type[turu.core.tag.Tag],\n        operation: str,\n        seq_of_parameters: Sequence[Iterator[Any]],\n    ) -&gt; turu.core.async_cursor.AsyncCursor[Never, Iterator[Any]]:\n        return cast(\n            turu.core.async_cursor.AsyncCursor,\n            await self.executemany(operation, seq_of_parameters),\n        )\n\n    @override\n    async def fetchone(self) -&gt; Optional[turu.core.async_cursor.GenericRowType]:\n        row = await self._raw_cursor.fetchone()\n        if row is None:\n            return None\n\n        return _map_row(self._row_type, row)\n\n    @override\n    async def fetchmany(\n        self, size: Optional[int] = None\n    ) -&gt; List[turu.core.async_cursor.GenericRowType]:\n        return [\n            _map_row(self._row_type, row)\n            for row in (\n                await self._raw_cursor.fetchmany(\n                    size if size is not None else self.arraysize\n                )\n            )\n        ]\n\n    @override\n    async def fetchall(self) -&gt; List[turu.core.async_cursor.GenericRowType]:\n        return [\n            _map_row(self._row_type, row) for row in await self._raw_cursor.fetchall()\n        ]\n\n    @override\n    def __aiter__(self) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericRowType]\":\n        self._aiter = self._raw_cursor.__aiter__()\n        return self\n\n    @override\n    async def __anext__(self) -&gt; turu.core.async_cursor.GenericRowType:\n        if self._aiter is None:\n            self._aiter = self._raw_cursor.__aiter__()\n\n        next_row = await self._aiter.__anext__()\n        return _map_row(self._row_type, next_row)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.arraysize","title":"<code>arraysize: int</code>  <code>property</code> <code>writable</code>","text":"<p>This read/write attribute specifies the number of rows to fetch at a time with <code>.fetchmany()</code>. It defaults to 1 meaning to fetch a single row at a time.</p> <p>Implementations must observe this value with respect to the <code>.fetchmany()</code> method, but are free to interact with the database a single row at a time. It may also be used in the implementation of <code>.executemany()</code>.</p>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.rowcount","title":"<code>rowcount: int</code>  <code>property</code>","text":"<p>the number of rows that the last .execute*() produced (for DQL statements like ) or affected (for DML statements like or ).</p> <p>The attribute is -1 in case no .execute*() has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.execute","title":"<code>execute(operation, parameters=None)</code>  <code>async</code>","text":"<p>Prepare and execute a database operation (query or command).</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def execute(\n    self, operation: str, parameters: Optional[\"Iterator[Any]\"] = None, /\n) -&gt; \"AsyncCursor[Tuple[Any]]\":\n    await self._raw_cursor.execute(operation, parameters)\n    self._row_type = None\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.execute_map","title":"<code>execute_map(row_type, operation, parameters=None)</code>  <code>async</code>","text":"<p>Execute a database operation (query or command) and map each row to a <code>row_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>parameters</code> <code>Optional[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncCursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def execute_map(\n    self,\n    row_type: Type[turu.core.async_cursor.GenericNewRowType],\n    operation: str,\n    parameters: \"Optional[Iterator[Any]]\" = None,\n    /,\n) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n    await self._raw_cursor.execute(operation, parameters)\n    self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.execute_with_tag","title":"<code>execute_with_tag(tag, operation, parameters=None)</code>  <code>async</code>","text":"<p>Execute a database operation (Insert, Update, Delete) with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method executes an operation (Insert, Update, Delete) that does not return a value with a tag. This tag is used to verify that the specified operation is executed in order when testing with Mock.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def execute_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    parameters: \"Optional[Iterator[Any]]\" = None,\n) -&gt; turu.core.async_cursor.AsyncCursor[Never, Iterator[Any]]:\n    return cast(\n        turu.core.async_cursor.AsyncCursor,\n        await self.execute(operation, parameters),\n    )\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.executemany","title":"<code>executemany(operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Prepare a database operation (query or command) and then execute it against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def executemany(\n    self, operation: str, seq_of_parameters: \"Sequence[Iterator[Any]]\", /\n) -&gt; \"AsyncCursor[Tuple[Any]]\":\n    await self._raw_cursor.executemany(operation, seq_of_parameters)\n    self._row_type = None\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.executemany_map","title":"<code>executemany_map(row_type, operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Execute a database operation (query or command) against all parameter sequences or mappings.</p> <p>Parameters:</p> Name Type Description Default <code>row_type</code> <code>Type[GenericNewRowType]</code> <p>The type of the row that will be returned.</p> required <code>operation</code> <code>str</code> <p>A database operation (query or command).</p> required <code>seq_of_parameters</code> <code>Sequence[Parameters]</code> <p>Parameters may be provided as sequence or mapping and will be bound to variables in the operation.</p> required <p>Returns:</p> Type Description <code>AsyncCursor[GenericNewRowType, Parameters]</code> <p>A cursor that holds a reference to an operation.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def executemany_map(\n    self,\n    row_type: Type[turu.core.async_cursor.GenericNewRowType],\n    operation: str,\n    seq_of_parameters: \"Sequence[Iterator[Any]]\",\n    /,\n) -&gt; \"AsyncCursor[turu.core.async_cursor.GenericNewRowType]\":\n    await self._raw_cursor.executemany(operation, seq_of_parameters)\n    self._row_type = cast(Type[turu.core.async_cursor.GenericRowType], row_type)\n\n    return cast(AsyncCursor, self)\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.executemany_with_tag","title":"<code>executemany_with_tag(tag, operation, seq_of_parameters)</code>  <code>async</code>","text":"<p>Execute a database operation (Insert, Update, Delete) against all parameter sequences or mappings with a tag.</p> <p>This is not defined in PEP 249,</p> <p>This method executes an operation (Insert, Update, Delete) that does not return a value with a tag. This tag is used to verify that the specified operation is executed in order when testing with Mock.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def executemany_with_tag(\n    self,\n    tag: Type[turu.core.tag.Tag],\n    operation: str,\n    seq_of_parameters: Sequence[Iterator[Any]],\n) -&gt; turu.core.async_cursor.AsyncCursor[Never, Iterator[Any]]:\n    return cast(\n        turu.core.async_cursor.AsyncCursor,\n        await self.executemany(operation, seq_of_parameters),\n    )\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.fetchall","title":"<code>fetchall()</code>  <code>async</code>","text":"<p>Fetch all (remaining) rows of a query result</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def fetchall(self) -&gt; List[turu.core.async_cursor.GenericRowType]:\n    return [\n        _map_row(self._row_type, row) for row in await self._raw_cursor.fetchall()\n    ]\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.fetchmany","title":"<code>fetchmany(size=None)</code>  <code>async</code>","text":"<p>Fetch the next set of rows of a query result.</p> <p>An empty sequence is returned when no more rows are available.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch per call.     If this parameter is not used, it is usually refer to use the <code>.arraysize</code> attribute (Default is <code>1</code>).     If this parameter is used, then it is best for it to retain the same value from one <code>.fetchmany()</code> call to the next.</p> <code>None</code> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def fetchmany(\n    self, size: Optional[int] = None\n) -&gt; List[turu.core.async_cursor.GenericRowType]:\n    return [\n        _map_row(self._row_type, row)\n        for row in (\n            await self._raw_cursor.fetchmany(\n                size if size is not None else self.arraysize\n            )\n        )\n    ]\n</code></pre>"},{"location":"api/turu-sqlite3/#turu.sqlite3.AsyncCursor.fetchone","title":"<code>fetchone()</code>  <code>async</code>","text":"<p>Fetch the next row of a query result set.</p> Source code in <code>turu-sqlite3/src/turu/sqlite3/async_cursor.py</code> <pre><code>@override\nasync def fetchone(self) -&gt; Optional[turu.core.async_cursor.GenericRowType]:\n    row = await self._raw_cursor.fetchone()\n    if row is None:\n        return None\n\n    return _map_row(self._row_type, row)\n</code></pre>"}]}